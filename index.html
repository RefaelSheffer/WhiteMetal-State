<!doctype html>
<html lang="he">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SLV Monitor</title>
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <style>
    :root {
      --bg: #0b0f17;
      --card: #111a2b;
      --border: #1e2a45;
      --muted: #a8b4d6;
      --text: #e8eefc;
      --accent: #4c9cff;
      --success: #22c55e;
      --danger: #f43f5e;
    }
    body { font-family: system-ui, Arial; margin: 0; background: var(--bg); color: var(--text); }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 24px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 16px; }
    .big { font-size: 28px; font-weight: 800; }
    .muted { color: var(--muted); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .alert { margin-top: 10px; background: rgba(255, 159, 64, 0.12); border: 1px solid #ff9f40; color: #ffd7a2; padding: 10px 12px; border-radius: 10px; line-height: 1.5; }
    .kpis { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-top: 12px; }
    .kpi { background: #0d1424; border: 1px solid var(--border); border-radius: 12px; padding: 10px; }
    .kpi .v { font-size: 18px; font-weight: 700; margin-top: 4px; }
    .kpi .small { font-size: 12px; color: var(--muted); margin-top: 4px; display: block; line-height: 1.4; }
    .pill { display: inline-block; padding: 4px 10px; border-radius: 999px; font-size: 13px; border: 1px solid var(--border); text-transform: uppercase; letter-spacing: 0.5px; }
    .pill.up { background: rgba(34, 197, 94, 0.12); color: var(--success); }
    .pill.down { background: rgba(244, 63, 94, 0.12); color: var(--danger); }
    .pill.neutral { background: rgba(255,255,255,0.06); color: var(--text); }
    .controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; margin: 12px 0 8px; }
    .btn { background: #0d1424; color: var(--text); border: 1px solid var(--border); border-radius: 10px; padding: 6px 10px; cursor: pointer; }
    .btn.active { background: #1f2d4a; border-color: var(--accent); }
    .toggle { display: inline-flex; gap: 6px; align-items: center; padding: 6px 10px; background: #0d1424; border: 1px solid var(--border); border-radius: 10px; cursor: pointer; }
    .toggle input { accent-color: var(--accent); }
    .header-top { display: flex; justify-content: space-between; gap: 12px; }
    .header-content { flex: 1; min-width: 0; }
    .meta-row { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    .badge { display: inline-block; padding: 4px 8px; border-radius: 8px; background: rgba(255,255,255,0.06); font-size: 12px; margin-right: 6px; }
    .section-title { font-size: 18px; font-weight: 700; display: flex; align-items: center; gap: 8px; }
    .chip { padding: 4px 8px; border-radius: 999px; border: 1px solid var(--border); font-size: 12px; }
    .table { width: 100%; border-collapse: collapse; margin-top: 8px; font-size: 14px; }
    .table th, .table td { padding: 8px; text-align: right; border-bottom: 1px solid var(--border); }
    .table th { color: var(--muted); font-weight: 700; }
    .table td { color: var(--text); }
    body[dir="ltr"] .table th, body[dir="ltr"] .table td { text-align: left; }
    .flex { display: flex; align-items: center; gap: 8px; }
    .space { flex: 1; }
    .settings { background: rgba(255,255,255,0.03); border-radius: 12px; padding: 12px; margin-top: 10px; display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px; }
    label.small { font-size: 12px; color: var(--muted); display: block; margin-bottom: 6px; }
    input, select { width: 100%; padding: 8px 10px; border-radius: 10px; border: 1px solid var(--border); background: #0d1424; color: var(--text); }
    .subtitle { font-size: 14px; color: var(--muted); margin-top: 4px; }
    .cost-impact { margin-top: 10px; background: rgba(255,255,255,0.04); border: 1px solid var(--border); border-radius: 12px; padding: 10px; color: var(--muted); font-size: 13px; line-height: 1.5; }
    .cost-impact strong { color: var(--text); }
    @media (max-width: 900px) { .row { grid-template-columns: 1fr; } }
    a { color: #8bb2ff; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="header-top">
        <div class="header-content">
          <div class="big" data-i18n="title">SLV Monitor</div>
          <div class="muted" data-i18n="subtitle">דשבורד סטטי ב-GitHub Pages + “מוח” שרץ ב-GitHub Actions ומעדכן JSON.</div>
          <div class="muted mono" id="updated">Loading…</div>
          <div class="meta-row">
            <span class="badge"><span data-i18n="metaSourceLabel">Data source</span>: <span class="mono" id="metaSource">—</span></span>
            <span class="badge"><span data-i18n="metaCoverageLabel">Coverage</span>: <span class="mono" id="metaCoverage">—</span></span>
            <span class="badge"><span data-i18n="metaUpdatedLabel">Last updated</span>: <span class="mono" id="metaUpdated">—</span></span>
          </div>
        </div>
        <button class="btn" id="langToggle" aria-label="Switch language">English</button>
      </div>
      <div class="alert" data-i18n="alert">
        המלצות המערכת הן תוצאה של עיבוד סטטיסטי ואינן מהוות ייעוץ או הנחיה לביצוע פעולה מיידית. מומלץ לשלב את האיתותים עם גורמים נוספים כמו חדשות מאקרו, מדיניות מוניטרית ושיקולים אישיים אחרים.
      </div>
    </div>

    <div style="height:16px"></div>

    <div class="row">
      <div class="card">
        <div class="section-title" data-i18n="signalNowTitle">Signal עכשיו</div>
        <div class="flex" style="margin-top:8px; gap:12px;">
          <div class="big" id="action">—</div>
          <span class="pill neutral" id="regimeTag">—</span>
          <span class="pill neutral" id="edgeTag">Edge —</span>
        </div>
        <div class="muted" style="margin-top:4px;"><span data-i18n="confidenceLabel">Confidence</span>: <span class="mono" id="confidence">—</span></div>
        <div class="kpis">
          <div class="kpi">
            <div class="muted" data-i18n="scoreTotalLabel">Score Total</div>
            <div class="v mono" id="scoreTotal">—</div>
            <span class="small" id="edgeScore">—</span>
          </div>
          <div class="kpi">
            <div class="muted" data-i18n="scorePriceLabel">Price Score</div>
            <div class="v mono" id="scorePrice">—</div>
          </div>
          <div class="kpi">
            <div class="muted" data-i18n="scoreCOTLabel">COT Score</div>
            <div class="v mono" id="scoreCOT">—</div>
          </div>
        </div>
        <div class="kpis">
          <div class="kpi">
            <div class="muted" data-i18n="latestCloseLabel">Latest Close</div>
            <div class="v mono" id="lastClose">—</div>
            <span class="small" id="mas">—</span>
          </div>
          <div class="kpi">
            <div class="muted" data-i18n="momLabel">1M Mom%</div>
            <div class="v mono" id="mom">—</div>
            <span class="small" id="cotLine">—</span>
          </div>
          <div class="kpi">
            <div class="muted" data-i18n="edgarLabel">EDGAR</div>
            <div class="v mono" id="edgarLine">—</div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="section-title flex">
          <span data-i18n="backtestSettings">Backtest settings</span>
          <button class="btn" id="toggleSettings" style="margin-inline-start:auto;" data-i18n="openSettings">Open</button>
        </div>
        <div class="subtitle" data-i18n="settingsHint">שליטה מהירה לטווחי בדיקה, עלויות ואסטרטגיה.</div>
        <div id="settingsPanel" class="settings" style="display:none;">
          <div>
            <label class="small" data-i18n="startDate">Start date</label>
            <input type="date" id="startDate" />
          </div>
          <div>
            <label class="small" data-i18n="endDate">End date</label>
            <input type="date" id="endDate" />
          </div>
          <div>
            <label class="small" data-i18n="costsLabel">Costs (bps per trade)</label>
            <input type="number" id="costsInput" min="0" step="1" value="10" />
          </div>
          <div>
            <label class="small" data-i18n="strategyPick">Strategy</label>
            <select id="strategySelect">
              <option value="trend" data-i18n="strategyTrend">Trend</option>
              <option value="range" data-i18n="strategyRange">Range</option>
              <option value="hybrid" data-i18n="strategyHybrid" selected>Hybrid</option>
            </select>
          </div>
          <div>
            <label class="small" data-i18n="maWindow">MA window (trend filter)</label>
            <input type="number" id="maWindowInput" min="5" max="400" step="1" value="50" />
          </div>
          <div>
            <label class="small" data-i18n="rsiPeriod">RSI period</label>
            <input type="number" id="rsiPeriodInput" min="5" max="60" step="1" value="14" />
          </div>
          <div>
            <label class="small" data-i18n="rsiOversold">RSI oversold</label>
            <input type="number" id="rsiOversoldInput" min="1" max="60" step="1" value="35" />
          </div>
          <div>
            <label class="small" data-i18n="rsiOverbought">RSI overbought</label>
            <input type="number" id="rsiOverboughtInput" min="40" max="95" step="1" value="65" />
          </div>
          <div>
            <label class="small" data-i18n="bandWindow">Bollinger window</label>
            <input type="number" id="bandWindowInput" min="5" max="200" step="1" value="20" />
          </div>
          <div>
            <label class="small" data-i18n="bandStd">Band σ (std dev)</label>
            <input type="number" id="bandStdInput" min="1" max="4" step="0.1" value="2" />
          </div>
          <div>
            <label class="small" data-i18n="grossNet">Gross / Net</label>
            <div class="flex">
              <label class="toggle"><input type="radio" name="pnltoggle" value="gross" checked /> <span data-i18n="grossLabel">Gross</span></label>
              <label class="toggle"><input type="radio" name="pnltoggle" value="net" /> <span data-i18n="netLabel">Net</span></label>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div style="height:16px"></div>

    <div class="card">
      <div class="section-title" data-i18n="priceTitle">Price</div>
      <div class="controls">
        <div class="muted" data-i18n="rangeLabel">טווח זמן:</div>
        <button class="btn active" data-range="3m">3M</button>
        <button class="btn" data-range="1y">1Y</button>
        <button class="btn" data-range="all">All</button>
        <span class="space"></span>
        <label class="toggle"><input type="checkbox" id="toggleMa" checked /><span data-i18n="maToggle">MAs</span></label>
        <label class="toggle"><input type="checkbox" id="toggleBoll" checked /><span data-i18n="bollToggle">Bands</span></label>
        <label class="toggle"><input type="checkbox" id="toggleSignals" checked /><span data-i18n="signalsToggle">Buy/Sell</span></label>
      </div>
      <div id="chart" style="height:440px;"></div>
      <div class="muted" style="margin-top:8px;" data-i18n="cycleTitle">מחזורי Peaks/Troughs אחרונים</div>
      <table class="table" id="cycleTable">
        <thead>
          <tr>
            <th data-i18n="cycleEndDate">תאריך סיום</th>
            <th data-i18n="cycleStartDate">תאריך התחלה</th>
            <th data-i18n="cycleDirection">כיוון</th>
            <th data-i18n="cycleLength">אורך</th>
            <th data-i18n="cycleAmplitude">אמפליטודה</th>
          </tr>
        </thead>
        <tbody>
          <tr><td colspan="5" class="muted">Loading…</td></tr>
        </tbody>
      </table>
    </div>

    <div style="height:16px"></div>

    <div class="row">
      <div class="card">
        <div class="section-title" data-i18n="equityTitle">Equity vs Benchmark (SLV)</div>
        <div class="controls" style="margin-top:6px;">
          <span class="muted" data-i18n="equityViewLabel">View:</span>
          <label class="toggle"><input type="radio" name="equityMode" value="gross" checked /> <span data-i18n="grossLabel">Gross</span></label>
          <label class="toggle"><input type="radio" name="equityMode" value="net" /> <span data-i18n="netLabel">Net (after cost)</span></label>
          <span class="space"></span>
          <span class="muted" data-i18n="perfSummaryUpdatedLabel">עודכן</span>: <span class="mono" id="perfSummaryUpdated">—</span>
        </div>
        <div class="cost-impact" id="costImpact">
          <div><span data-i18n="costsSelectedLabel">Selected costs</span>: <strong class="mono" id="costsSelected">—</strong></div>
          <div><span data-i18n="costDragLabel">Cost drag vs gross</span>: <strong class="mono" id="costDragVal">—</strong></div>
          <div><span data-i18n="grossNetImpactLabel">Gross → Net</span>: <span class="mono" id="grossReturnVal">—</span> → <span class="mono" id="netReturnVal">—</span></div>
        </div>
        <div id="perfChart" style="height:320px;"></div>
        <table class="table" id="perfTable" style="margin-top:12px;">
          <thead>
            <tr>
              <th data-i18n="seriesLabel">Series</th>
              <th data-i18n="totalReturnLabel">Total Return</th>
              <th data-i18n="maxDrawdownLabel">Max Drawdown</th>
              <th data-i18n="sharpeLabel">Sharpe</th>
              <th data-i18n="sortinoLabel">Sortino</th>
            </tr>
          </thead>
          <tbody id="perfTableBody">
            <tr><td colspan="5" class="muted">Loading…</td></tr>
          </tbody>
        </table>
      </div>

      <div class="card">
        <div class="section-title" data-i18n="riskTitle">Risk metrics</div>
        <div class="kpis">
          <div class="kpi">
            <div class="muted" data-i18n="maxDrawdownLabel">Max Drawdown</div>
            <div class="v mono" id="riskDd">—</div>
          </div>
          <div class="kpi">
            <div class="muted" data-i18n="ulcerLabel">Ulcer Index</div>
            <div class="v mono" id="riskUlcer">—</div>
          </div>
          <div class="kpi">
            <div class="muted" data-i18n="worstMonthLabel">Worst Month</div>
            <div class="v mono" id="riskWorst">—</div>
          </div>
        </div>
        <div class="section-title" style="margin-top:16px;" data-i18n="tradeLogTitle">Trade log</div>
        <table class="table" id="tradeTable">
          <thead>
            <tr>
              <th data-i18n="tradeEntry">Entry</th>
              <th data-i18n="tradeExit">Exit</th>
              <th data-i18n="tradeReason">Trigger</th>
              <th data-i18n="tradeReturn">Return%</th>
              <th data-i18n="tradeHold">Hold</th>
            </tr>
          </thead>
          <tbody>
            <tr><td colspan="5" class="muted">Loading…</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div style="height:16px"></div>

    <div class="row">
      <div class="card" id="performanceCard">
        <div class="section-title" data-i18n="performanceScoreTitle">ציון ביצועים כולל</div>
        <div class="muted"><span data-i18n="perfSummaryUpdatedLabel">עודכן</span>: <span class="mono" id="perfSummaryUpdated2">—</span></div>
        <div class="kpis">
          <div class="kpi">
            <div class="muted" data-i18n="algoScoreLabel">ציון אלגוריתם</div>
            <div class="v mono" id="algoScore">—</div>
            <span class="small" id="algoScoreMeta">—</span>
          </div>
        </div>
        <div class="kpis">
          <div class="kpi">
            <div class="muted" data-i18n="hitRateLabel">Hit Rate</div>
            <div class="v mono" id="hitRate">—</div>
          </div>
          <div class="kpi">
            <div class="muted" data-i18n="avgReturn5dLabel">Avg Return 5d</div>
            <div class="v mono" id="avgReturn5d">—</div>
          </div>
          <div class="kpi">
            <div class="muted" data-i18n="avgReturn10dLabel">Avg Return 10d</div>
            <div class="v mono" id="avgReturn10d">—</div>
          </div>
          <div class="kpi">
            <div class="muted" data-i18n="maxDrawdownLabel">Max Drawdown</div>
            <div class="v mono" id="maxDrawdown">—</div>
          </div>
        </div>
      </div>

      <div class="card" id="decompCard">
        <div class="section-title" data-i18n="decompTitle">Decomposition</div>
        <div class="muted"><span data-i18n="decompUpdatedLabel">Updated</span>: <span class="mono" id="decompUpdated">—</span></div>
        <div class="muted"><span data-i18n="decompPeriodLabel">Period</span>: <span class="mono" id="decompPeriod">—</span></div>
        <div id="trendChart" style="height:180px; margin-top:10px;"></div>
        <div id="seasonalChart" style="height:180px; margin-top:10px;"></div>
      </div>
    </div>
  </div>

<script>
async function getJson(path) {
  const r = await fetch(path, { cache: "no-store" });
  if (!r.ok) throw new Error(`Failed ${path}: ${r.status}`);
  return await r.json();
}

function detectLang() {
  const stored = localStorage.getItem("lang");
  if (stored) return stored;
  const nav = navigator.language || navigator.userLanguage || "";
  return nav.toLowerCase().startsWith("he") ? "he" : "en";
}

const translations = {
  he: {
    title: "SLV Monitor",
    subtitle: "דשבורד סטטי ב-GitHub Pages + “מוח” שרץ ב-GitHub Actions ומעדכן JSON.",
    alert: "המלצות המערכת הן תוצאה של עיבוד סטטיסטי ואינן מהוות ייעוץ או הנחיה לביצוע פעולה מיידית. מומלץ לשלב את האיתותים עם גורמים נוספים כמו חדשות מאקרו, מדיניות מוניטרית ושיקולים אישיים אחרים.",
    priceTitle: "מחיר",
    rangeLabel: "טווח זמן:",
    cycleTitle: "מחזורי Peaks/Troughs אחרונים",
    cycleEndDate: "תאריך סיום",
    cycleStartDate: "תאריך התחלה",
    cycleDirection: "כיוון",
    cycleLength: "אורך",
    cycleAmplitude: "אמפליטודה",
    performanceScoreTitle: "ציון ביצועים כולל",
    perfSummaryUpdatedLabel: "עודכן",
    equityTitle: "תשואת אלגו מול SLV",
    performanceTitle: "ביצועים",
    algoScoreLabel: "ציון אלגוריתם",
    sharpeLabel: "Sharpe Ratio",
    cycleCaptureLabel: "ציון מחזורי",
    rsiLabel: "RSI (14)",
    stdLabel: "סטיית תקן מתגלגלת (20)",
    macdLabel: "MACD (12/26/9)",
    bollLabel: "בולינגר (20, 2σ)",
    obvLabel: "OBV",
    maLongLabel: "MA1000",
    perfUpdatedLabel: "עדכון ביצועים",
    decompTitle: "פירוק (Decomposition)",
    decompUpdatedLabel: "עדכון",
    decompPeriodLabel: "אורך מחזור",
    trendTitle: "מגמה",
    seasonalTitle: "עונתיות / שארית",
    noCycles: "לא זוהו מחזורים עדיין.",
    perfSeriesUnavailable: "סדרת ביצועים לא זמינה.",
    benchUnavailable: "חלון מדד חסר.",
    decompUnavailable: "פירוק לא זמין.",
    seriesLabel: "סדרה",
    totalReturnLabel: "תשואה כוללת",
    sortinoLabel: "Sortino",
    strategyLabel: "אסטרטגיה",
    buyHoldLabel: "Buy & Hold",
    updatedPrefix: "עודכן (UTC)",
    metaSourceLabel: "מקור נתונים",
    metaCoverageLabel: "טווח כיסוי",
    metaUpdatedLabel: "עדכון אחרון",
    confidenceLabel: "Confidence",
    scoreTotalLabel: "Score Total",
    scorePriceLabel: "Price Score",
    scoreCOTLabel: "COT Score",
    latestCloseLabel: "מחיר סגירה אחרון",
    maLabel: "ממוצעים 20/50/200",
    momLabel: "מומנטום 1M",
    cotLabel: "COT (Silver)",
    edgarLabel: "EDGAR",
    cotUnavailable: "COT לא זמין (בינתיים).",
    edgarNoFiling: "לא נמצאה הגשה אחרונה.",
    edgarUnavailable: "EDGAR לא זמין (בינתיים).",
    hitRateLabel: "Hit Rate",
    avgReturn5dLabel: "תשואה ממוצעת 5 ימים",
    avgReturn10dLabel: "תשואה ממוצעת 10 ימים",
    maxDrawdownLabel: "Max Drawdown",
    rsiToggle: "RSI",
    stdToggle: "StdDev",
    macdToggle: "MACD",
    bollToggle: "בולינגר",
    obvToggle: "OBV",
    maLongToggle: "MA1000",
    decompToggle: "Decomposition",
    langToggleEnglish: "English",
    langToggleHebrew: "עברית",
    switchToEnglishAria: "Switch to English",
    switchToHebrewAria: "החלף לעברית",
    signalNowTitle: "Signal עכשיו",
    backtestSettings: "Backtest settings",
    openSettings: "Open",
    settingsHint: "שליטה מהירה לטווחי בדיקה, עלויות ואסטרטגיה.",
    maWindow: "חלון MA (מסנן מגמה)",
    rsiPeriod: "תקופת RSI",
    rsiOversold: "RSI מכירות יתר",
    rsiOverbought: "RSI קניות יתר",
    bandWindow: "חלון בולינגר",
    bandStd: "סטיית תקן",
    startDate: "Start date",
    endDate: "End date",
    costsLabel: "עלויות (bps)",
    costsSelectedLabel: "עלות נבחרת (bps לעסקה)",
    costDragLabel: "שחיקה מול תשואת Gross",
    grossNetImpactLabel: "תשואה: Gross → Net",
    strategyPick: "Strategy",
    strategyTrend: "Trend",
    strategyRange: "Range",
    strategyHybrid: "Hybrid",
    grossNet: "Gross / Net",
    grossLabel: "Gross",
    netLabel: "Net",
    maToggle: "MAs",
    signalsToggle: "Buy/Sell",
    equityViewLabel: "תצוגת רווחיות",
    riskTitle: "מדדי סיכון",
    ulcerLabel: "Ulcer Index",
    worstMonthLabel: "Worst month",
    tradeLogTitle: "יומן עסקאות",
    tradeEntry: "כניסה",
    tradeExit: "יציאה",
    tradeReason: "Trigger",
    tradeReturn: "רווח %",
    tradeHold: "זמן החזקה"
  },
  en: {
    title: "SLV Monitor",
    subtitle: "Static dashboard on GitHub Pages + a 'brain' running in GitHub Actions updating JSON.",
    alert: "System recommendations are the result of statistical processing and do not constitute advice or a call for immediate action. Combine signals with other factors like macro news, monetary policy, and personal considerations.",
    priceTitle: "Price",
    rangeLabel: "Range:",
    cycleTitle: "Recent Peaks/Troughs Cycles",
    cycleEndDate: "End Date",
    cycleStartDate: "Start Date",
    cycleDirection: "Direction",
    cycleLength: "Length",
    cycleAmplitude: "Amplitude",
    performanceScoreTitle: "Performance Scorecard",
    perfSummaryUpdatedLabel: "Updated",
    equityTitle: "Equity vs Benchmark (SLV)",
    performanceTitle: "Performance",
    algoScoreLabel: "Algorithm Score",
    sharpeLabel: "Sharpe Ratio",
    cycleCaptureLabel: "Cycle Capture",
    rsiLabel: "RSI (14)",
    stdLabel: "Rolling StdDev (20)",
    macdLabel: "MACD (12/26/9)",
    bollLabel: "Bollinger Bands (20, 2σ)",
    obvLabel: "OBV",
    maLongLabel: "MA1000",
    perfUpdatedLabel: "Perf Updated",
    decompTitle: "Decomposition",
    decompUpdatedLabel: "Updated",
    decompPeriodLabel: "Period",
    trendTitle: "Trend",
    seasonalTitle: "Seasonal / Residual",
    noCycles: "No cycles detected yet.",
    perfSeriesUnavailable: "Performance series unavailable.",
    benchUnavailable: "Benchmark window unavailable.",
    decompUnavailable: "Decomposition unavailable.",
    seriesLabel: "Series",
    totalReturnLabel: "Total Return",
    sortinoLabel: "Sortino",
    strategyLabel: "Strategy",
    buyHoldLabel: "Buy & Hold",
    updatedPrefix: "Updated (UTC)",
    metaSourceLabel: "Data source",
    metaCoverageLabel: "Coverage",
    metaUpdatedLabel: "Last updated",
    confidenceLabel: "Confidence",
    scoreTotalLabel: "Score Total",
    scorePriceLabel: "Price Score",
    scoreCOTLabel: "COT Score",
    latestCloseLabel: "Latest Close",
    maLabel: "MA20/50/200",
    momLabel: "1M Mom%",
    cotLabel: "COT (Silver)",
    edgarLabel: "EDGAR",
    cotUnavailable: "COT unavailable (yet).",
    edgarNoFiling: "No latest filing found.",
    edgarUnavailable: "EDGAR unavailable (yet).",
    hitRateLabel: "Hit Rate",
    avgReturn5dLabel: "Avg Return 5d",
    avgReturn10dLabel: "Avg Return 10d",
    maxDrawdownLabel: "Max Drawdown",
    rsiToggle: "RSI",
    stdToggle: "StdDev",
    macdToggle: "MACD",
    bollToggle: "Bollinger",
    obvToggle: "OBV",
    maLongToggle: "MA1000",
    decompToggle: "Decomposition",
    langToggleEnglish: "English",
    langToggleHebrew: "עברית",
    switchToEnglishAria: "Switch to English",
    switchToHebrewAria: "Switch to Hebrew",
    signalNowTitle: "Signal now",
    backtestSettings: "Backtest settings",
    openSettings: "Open",
    settingsHint: "Quick control over test window, costs and regime.",
    maWindow: "MA window (trend filter)",
    rsiPeriod: "RSI period",
    rsiOversold: "RSI oversold",
    rsiOverbought: "RSI overbought",
    bandWindow: "Bollinger window",
    bandStd: "Band σ (std dev)",
    startDate: "Start date",
    endDate: "End date",
    costsLabel: "Costs (bps)",
    costsSelectedLabel: "Selected costs (bps per trade)",
    costDragLabel: "Cost drag vs gross return",
    grossNetImpactLabel: "Gross → Net return",
    strategyPick: "Strategy",
    strategyTrend: "Trend",
    strategyRange: "Range",
    strategyHybrid: "Hybrid",
    grossNet: "Gross / Net",
    grossLabel: "Gross",
    netLabel: "Net",
    maToggle: "MAs",
    signalsToggle: "Buy/Sell",
    equityViewLabel: "Equity view",
    riskTitle: "Risk metrics",
    ulcerLabel: "Ulcer Index",
    worstMonthLabel: "Worst month",
    tradeLogTitle: "Trade log",
    tradeEntry: "Entry",
    tradeExit: "Exit",
    tradeReason: "Trigger",
    tradeReturn: "Return%",
    tradeHold: "Hold"
  }
};

function fmt(x, d = 2) {
  if (x === null || x === undefined || Number.isNaN(x)) return "—";
  return Number(x).toFixed(d);
}

function fmtPct(x, d = 1) {
  if (x === null || x === undefined || Number.isNaN(x)) return "—";
  return `${(Number(x) * 100).toFixed(d)}%`;
}

function movingAverage(arr, period) {
  const res = [];
  for (let i = 0; i < arr.length; i++) {
    if (i + 1 < period) { res.push(null); continue; }
    const slice = arr.slice(i + 1 - period, i + 1);
    const avg = slice.reduce((a, b) => a + b, 0) / period;
    res.push(avg);
  }
  return res;
}

function bollinger(arr, period = 20, mult = 2) {
  const ma = movingAverage(arr, period);
  const upper = [];
  const lower = [];
  for (let i = 0; i < arr.length; i++) {
    if (i + 1 < period) { upper.push(null); lower.push(null); continue; }
    const slice = arr.slice(i + 1 - period, i + 1);
    const mean = ma[i];
    const variance = slice.reduce((acc, v) => acc + (v - mean) ** 2, 0) / period;
    const std = Math.sqrt(variance);
    upper.push(mean + mult * std);
    lower.push(mean - mult * std);
  }
  return { ma, upper, lower };
}

function computeRsi(arr, period = 14) {
  const gains = [];
  const losses = [];
  for (let i = 1; i < arr.length; i++) {
    const change = arr[i] - arr[i - 1];
    gains.push(Math.max(change, 0));
    losses.push(Math.max(-change, 0));
  }
  const rsi = [null];
  for (let i = 1; i < arr.length; i++) {
    if (i < period) { rsi.push(null); continue; }
    const gainSlice = gains.slice(i - period, i);
    const lossSlice = losses.slice(i - period, i);
    const avgGain = gainSlice.reduce((a, b) => a + b, 0) / period;
    const avgLoss = lossSlice.reduce((a, b) => a + b, 0) / period;
    const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
    const value = 100 - 100 / (1 + rs);
    rsi.push(value);
  }
  return rsi;
}

function normalizeEquityFromPrices(prices) {
  const eq = [{ index: 0, equity: 1 }];
  for (let i = 1; i < prices.length; i++) {
    const prev = prices[i - 1];
    const curr = prices[i];
    const ret = (curr - prev) / prev;
    const last = eq[eq.length - 1].equity;
    eq.push({ index: i, equity: last * (1 + ret) });
  }
  return eq.slice(1);
}

function applyCosts(equitySeries, costBps = 0.0) {
  const cost = costBps / 10000;
  if (!cost) return equitySeries;
  const out = [];
  for (let i = 0; i < equitySeries.length; i++) {
    if (i === 0) { out.push({ ...equitySeries[i] }); continue; }
    const prev = equitySeries[i - 1].equity;
    const curr = equitySeries[i].equity;
    const grossRet = curr / prev - 1;
    const netRet = grossRet - cost;
    out.push({ index: equitySeries[i].index, equity: out[i - 1].equity * (1 + netRet) });
  }
  return out;
}

(async () => {
  const [meta, prices, signal, cot, edgar, decomposition, perfSummary, equityCurve, cycleStats] = await Promise.all([
    getJson("./public/data/meta.json"),
    getJson("./data/slv_prices.json"),
    getJson("./data/signal_latest.json"),
    getJson("./data/cot_silver.json"),
    getJson("./data/edgar_latest.json"),
    getJson("./public/data/perf/decomposition.json"),
    getJson("./public/data/perf/summary.json"),
    getJson("./public/data/perf/equity_curve.json"),
    getJson("./public/data/events/cycle_stats.json"),
  ]);

  const priceDates = prices.dates.map((d) => new Date(d));
  const state = {
    range: "3m",
    lang: detectLang(),
    showMa: true,
    showBoll: true,
    showSignals: true,
    showNet: false,
    costBps: 10,
    startDate: prices.dates[0],
    endDate: prices.dates[prices.dates.length - 1],
    maWindow: 50,
    rsiPeriod: 14,
    rsiOversold: 35,
    rsiOverbought: 65,
    bandWindow: 20,
    bandStd: 2,
  };
  const buyHoldCurve = normalizeEquityFromPrices(prices.close);
  let lastBacktest = null;

  function t(key) { return translations[state.lang]?.[key] ?? translations.en[key] ?? key; }

  function applyLanguage() {
    document.documentElement.lang = state.lang;
    document.body.dir = state.lang === "he" ? "rtl" : "ltr";
    document.querySelectorAll("[data-i18n]").forEach((el) => {
      const key = el.getAttribute("data-i18n");
      el.textContent = t(key);
    });
    const langBtn = document.getElementById("langToggle");
    langBtn.textContent = state.lang === "he" ? translations.en.langToggleEnglish : translations.he.langToggleHebrew;
    langBtn.setAttribute("aria-label", state.lang === "he" ? translations.en.switchToEnglishAria : translations.he.switchToHebrewAria);
  }

  function renderMeta() {
    const symbolText = meta?.symbol ? ` (${meta.symbol})` : "";
    const sourceText = meta?.source ? `${meta.source}${symbolText}` : "—";
    const coverageCore = meta?.start && meta?.end ? `${meta.start} → ${meta.end}` : "—";
    const rowsSuffix = Number.isFinite(meta?.rows) ? ` (${Number(meta.rows).toLocaleString()})` : "";

    document.getElementById("metaSource").textContent = sourceText;
    document.getElementById("metaCoverage").textContent = coverageCore === "—" ? "—" : `${coverageCore}${rowsSuffix}`;
    document.getElementById("metaUpdated").textContent = meta?.last_updated_utc ?? "—";
  }

  function getRangeMask(months, startDate, endDate) {
    const mask = [];
    const startBound = startDate ? new Date(startDate) : null;
    const endBound = endDate ? new Date(endDate) : null;
    const rangeStart = (() => {
      if (!months) return null;
      const lastDate = priceDates[priceDates.length - 1];
      const start = new Date(lastDate);
      start.setMonth(start.getMonth() - months);
      return start;
    })();

    priceDates.forEach((d, i) => {
      if (rangeStart && d < rangeStart) return;
      if (startBound && d < startBound) return;
      if (endBound && d > endBound) return;
      mask.push(i);
    });
    return mask;
  }

  function applyMask(arr, mask, accessor) {
    if (!Array.isArray(arr)) return [];
    return mask.map((i) => (accessor ? accessor(arr[i], i) : arr[i])).filter((v) => v !== undefined);
  }

  function renderPrice(range) {
    const months = range === "3m" ? 3 : range === "1y" ? 12 : null;
    const mask = getRangeMask(months, state.startDate, state.endDate);
    const dates = applyMask(prices.dates, mask);
    const close = applyMask(prices.close, mask);

    const opens = close.map((c, i) => (i === 0 ? c : close[i - 1]));
    const highs = close.map((c, i) => Math.max(c, opens[i]) * 1.002);
    const lows = close.map((c, i) => Math.min(c, opens[i]) * 0.998);

    const candle = { x: dates, open: opens, high: highs, low: lows, close, type: "candlestick", name: "SLV", increasing: { line: { color: "#22c55e" } }, decreasing: { line: { color: "#f43f5e" } } };

    const traces = [candle];
    if (state.showMa) {
      const ma20 = applyMask(movingAverage(prices.close, 20), mask);
      const ma50 = applyMask(movingAverage(prices.close, 50), mask);
      const ma200 = applyMask(movingAverage(prices.close, 200), mask);
      traces.push({ x: dates, y: ma20, mode: "lines", name: "MA20", line: { color: "#8bb2ff", width: 1.5 } });
      traces.push({ x: dates, y: ma50, mode: "lines", name: "MA50", line: { color: "#fbbf24", width: 1.2, dash: "dot" } });
      traces.push({ x: dates, y: ma200, mode: "lines", name: "MA200", line: { color: "#a855f7", width: 1.4, dash: "dash" } });
    }

    if (state.showBoll) {
      const bands = bollinger(prices.close, 20, 2);
      traces.push({ x: dates, y: applyMask(bands.upper, mask), mode: "lines", name: "Upper Band", line: { color: "rgba(255,255,255,0.35)", width: 1 } });
      traces.push({ x: dates, y: applyMask(bands.lower, mask), mode: "lines", name: "Lower Band", line: { color: "rgba(255,255,255,0.35)", width: 1 } });
    }

    const turningPoints = (cycleStats?.turning_points ?? []).filter((p) => {
      const d = new Date(p.date);
      if (state.startDate && d < new Date(state.startDate)) return false;
      if (state.endDate && d > new Date(state.endDate)) return false;
      if (!months) return true;
      const start = new Date(priceDates[priceDates.length - 1]);
      start.setMonth(start.getMonth() - months);
      return d >= start;
    });

    if (state.showSignals && turningPoints.length) {
      const buys = turningPoints.filter((p) => p.kind === "trough");
      const sells = turningPoints.filter((p) => p.kind === "peak");
      traces.push({ x: buys.map((p) => p.date), y: buys.map((p) => p.close), mode: "markers", type: "scatter", name: "BUY", marker: { color: "#22c55e", size: 9, symbol: "triangle-up" } });
      traces.push({ x: sells.map((p) => p.date), y: sells.map((p) => p.close), mode: "markers", type: "scatter", name: "SELL", marker: { color: "#f43f5e", size: 9, symbol: "triangle-down" } });
    }

    const layout = { paper_bgcolor: "rgba(0,0,0,0)", plot_bgcolor: "rgba(0,0,0,0)", margin: { l: 45, r: 15, t: 20, b: 40 }, xaxis: { showgrid: false, color: "#a8b4d6" }, yaxis: { showgrid: true, gridcolor: "#1e2a45", color: "#a8b4d6" } };
    Plotly.newPlot("chart", traces, layout, { displayModeBar: false });

    const cyclesData = cycleStats?.cycles ?? [];
    const tableBody = document.querySelector("#cycleTable tbody");
    const recentCycles = cyclesData.filter((cycle) => {
      const d = new Date(cycle.end_date);
      if (state.startDate && d < new Date(state.startDate)) return false;
      if (state.endDate && d > new Date(state.endDate)) return false;
      if (!months) return true;
      const start = new Date(priceDates[priceDates.length - 1]);
      start.setMonth(start.getMonth() - months);
      return d >= start;
    }).slice(-6).reverse();

    if (tableBody) {
      if (recentCycles.length === 0) {
        tableBody.innerHTML = `<tr><td colspan="5" class="muted">${t("noCycles")}</td></tr>`;
      } else {
        tableBody.innerHTML = recentCycles.map((cycle) => {
          const dir = cycle.direction === "upswing" ? "up" : "down";
          return `
            <tr>
              <td>${cycle.end_date}</td>
              <td>${cycle.start_date}</td>
              <td><span class="pill ${dir}">${cycle.direction}</span></td>
              <td>${cycle.length}d</td>
              <td>${fmtPct(cycle.amplitude, 1)}</td>
            </tr>
          `;
        }).join("");
      }
    }
  }

  function computeRisk(series, dates) {
    if (!series?.length || !dates?.length) return { dd: null, ulcer: null, worst: null };
    const vals = series.map((p) => p?.equity ?? p);
    let peak = vals[0];
    let maxDd = 0;
    const ddSquares = [];
    vals.forEach((v) => {
      peak = Math.max(peak, v);
      const dd = (v - peak) / peak;
      maxDd = Math.min(maxDd, dd);
      ddSquares.push((dd * 100) ** 2);
    });
    const ulcer = Math.sqrt(ddSquares.reduce((a, b) => a + b, 0) / ddSquares.length);
    // monthly
    const monthMap = new Map();
    vals.forEach((v, i) => {
      const key = `${dates[i].getFullYear()}-${dates[i].getMonth() + 1}`;
      monthMap.set(key, v);
    });
    const keys = Array.from(monthMap.keys()).sort();
    let worst = null;
    for (let i = 1; i < keys.length; i++) {
      const prev = monthMap.get(keys[i - 1]);
      const curr = monthMap.get(keys[i]);
      const r = curr / prev - 1;
      if (worst === null || r < worst) worst = r;
    }
    return { dd: maxDd, ulcer, worst };
  }

  function computeStats(series) {
    if (!series?.length) return { totalReturn: null, maxDrawdown: null, sharpe: null, sortino: null };
    const vals = series.map((p) => p?.equity ?? p);
    if (!vals.length) return { totalReturn: null, maxDrawdown: null, sharpe: null, sortino: null };

    const returns = [];
    for (let i = 1; i < vals.length; i++) {
      if (!vals[i - 1]) continue;
      returns.push(vals[i] / vals[i - 1] - 1);
    }

    const totalReturn = vals[vals.length - 1] / vals[0] - 1;
    let peak = vals[0];
    let maxDd = 0;
    vals.forEach((v) => { peak = Math.max(peak, v); maxDd = Math.min(maxDd, (v - peak) / peak); });

    const mean = returns.reduce((a, b) => a + b, 0) / (returns.length || 1);
    const variance = returns.reduce((a, b) => a + (b - mean) ** 2, 0) / (returns.length || 1);
    const std = Math.sqrt(variance);
    const sharpe = std ? mean / std : 0;
    const downside = returns.filter((r) => r < 0);
    const downsideMean = downside.reduce((a, b) => a + b, 0) / (downside.length || 1);
    const downsideVariance = downside.reduce((a, b) => a + (b - downsideMean) ** 2, 0) / (downside.length || 1);
    const downsideDev = Math.sqrt(downsideVariance);
    const sortino = downsideDev ? mean / downsideDev : 0;

    return {
      totalReturn,
      maxDrawdown: maxDd,
      sharpe,
      sortino,
    };
  }

  function buildBuyHoldSeries(closes) {
    const eq = [{ index: 0, equity: 1 }];
    for (let i = 1; i < closes.length; i++) {
      const ret = closes[i] / closes[i - 1] - 1;
      eq.push({ index: i, equity: eq[i - 1].equity * (1 + ret) });
    }
    return eq;
  }

  function runBacktest(closes, dates, options) {
    const ma = movingAverage(closes, options.maWindow || 50);
    const bands = bollinger(closes, options.bandWindow || 20, options.bandStd || 2);
    const rsi = computeRsi(closes, options.rsiPeriod || 14);

    const gross = [{ index: 0, equity: 1 }];
    const trades = [];
    let equity = 1;
    let inPosition = false;
    let entryIndex = null;
    let entryEquity = 1;

    for (let i = 1; i < closes.length; i++) {
      if (inPosition) {
        const ret = closes[i] / closes[i - 1] - 1;
        equity *= 1 + ret;
      }

      gross.push({ index: i, equity: Number(equity.toFixed(6)) });

      const maVal = ma[i];
      const rsiVal = rsi[i];
      const lower = bands.lower[i];

      const exitMa = inPosition && maVal !== null && closes[i] < maVal;
      const exitRsi = inPosition && rsiVal !== null && rsiVal >= (options.rsiOverbought || 65);
      if (exitMa || exitRsi) {
        const ret = equity / entryEquity - 1;
        trades.push({
          entry: dates[entryIndex],
          exit: dates[i],
          reason: exitRsi ? "RSI exit" : "MA breakdown",
          return: ret,
          hold: i - entryIndex,
        });
        inPosition = false;
        entryIndex = null;
        entryEquity = equity;
      }

      const entryBand = lower !== null && closes[i] <= lower;
      const entryRsi = rsiVal !== null && rsiVal <= (options.rsiOversold || 35);
      const entryTrend = maVal !== null && closes[i] >= maVal * 0.98;
      if (!inPosition && entryBand && entryRsi && entryTrend) {
        inPosition = true;
        entryIndex = i;
        entryEquity = equity;
      }
    }

    if (inPosition && entryIndex !== null) {
      const ret = equity / entryEquity - 1;
      trades.push({
        entry: dates[entryIndex],
        exit: dates[dates.length - 1],
        reason: "Range timeout",
        return: ret,
        hold: dates.length - 1 - entryIndex,
      });
    }

    const buyHold = buildBuyHoldSeries(closes);

    return {
      gross,
      buyHold,
      trades,
      stats: {
        strategy: computeStats(gross),
        benchmark: computeStats(buyHold),
      },
    };
  }

  function renderEquity(range) {
    const months = range === "3m" ? 3 : range === "1y" ? 12 : null;
    const mask = getRangeMask(months, state.startDate, state.endDate);
    const dates = applyMask(prices.dates, mask, (d) => new Date(d));
    const close = applyMask(prices.close, mask, (v) => v);
    if (!close.length) { document.getElementById("perfChart").textContent = t("perfSeriesUnavailable"); return; }

    const backtest = runBacktest(close, dates, state);
    lastBacktest = backtest;
    const gross = backtest.gross;
    const buyHold = backtest.buyHold;
    const net = applyCosts(gross, state.costBps);
    const grossStats = backtest.stats.strategy;
    const netStats = computeStats(net);
    const benchStats = backtest.stats.benchmark;
    const selectedStats = state.showNet ? netStats : grossStats;

    const chosen = state.showNet ? net : gross;
    const grossReturn = gross.length ? gross[gross.length - 1].equity - 1 : null;
    const netReturn = net.length ? net[net.length - 1].equity - 1 : null;
    const drag = grossReturn !== null && netReturn !== null ? netReturn - grossReturn : null;

    const traces = [
      { x: dates, y: chosen.map((p) => p.equity), mode: "lines", name: state.showNet ? "Strategy (Net)" : "Strategy (Gross)", line: { color: "#4c9cff" } },
      { x: dates, y: buyHold.map((p) => p.equity), mode: "lines", name: "Buy & Hold", line: { color: "#fbbf24", dash: "dot" } },
    ];

    const layout = { paper_bgcolor: "rgba(0,0,0,0)", plot_bgcolor: "rgba(0,0,0,0)", margin: { l: 45, r: 15, t: 20, b: 40 }, xaxis: { showgrid: false, color: "#a8b4d6" }, yaxis: { showgrid: true, gridcolor: "#1e2a45", color: "#a8b4d6" } };
    Plotly.newPlot("perfChart", traces, layout, { displayModeBar: false });

    const risk = computeRisk(chosen, dates);
    document.getElementById("riskDd").textContent = fmtPct(risk.dd, 2);
    document.getElementById("riskUlcer").textContent = fmt(risk.ulcer, 2);
    document.getElementById("riskWorst").textContent = fmtPct(risk.worst, 2);

    document.getElementById("costsSelected").textContent = `${state.costBps} bps (${fmt(state.costBps / 100, 2)})`;
    document.getElementById("costDragVal").textContent = fmtPct(drag, 2);
    document.getElementById("grossReturnVal").textContent = fmtPct(grossReturn, 2);
    document.getElementById("netReturnVal").textContent = fmtPct(netReturn, 2);

    const perfBody = document.getElementById("perfTableBody");
    const chosenReturn = selectedStats.totalReturn;
    const benchReturn = benchStats.totalReturn;
    const maxDdDisplay = fmtPct(selectedStats.maxDrawdown ?? risk.dd, 2);

    perfBody.innerHTML = `
      <tr><td>${state.showNet ? "Strategy (Net)" : "Strategy (Gross)"}</td><td>${fmtPct(chosenReturn, 2)}</td><td>${maxDdDisplay}</td><td>${fmt(selectedStats.sharpe, 2)}</td><td>${fmt(selectedStats.sortino, 2)}</td></tr>
      <tr><td>${t("buyHoldLabel")}</td><td>${fmtPct(benchReturn, 2)}</td><td>${fmtPct(benchStats.maxDrawdown, 2)}</td><td>${fmt(benchStats.sharpe, 2)}</td><td>${fmt(benchStats.sortino, 2)}</td></tr>
    `;
  }

  function renderTradeLog() {
    const tbody = document.querySelector("#tradeTable tbody");
    const trades = (lastBacktest?.trades ?? []).slice(-8).reverse();
    if (!trades.length) { tbody.innerHTML = `<tr><td colspan="5" class="muted">${t("noCycles")}</td></tr>`; return; }
    const fmtDate = (d) => {
      if (!d) return "—";
      if (d instanceof Date) return d.toISOString().slice(0, 10);
      return String(d).slice(0, 10);
    };

    tbody.innerHTML = trades.map((trade) => {
      return `<tr>
        <td>${fmtDate(trade.entry)}</td>
        <td>${fmtDate(trade.exit)}</td>
        <td>${trade.reason}</td>
        <td>${fmtPct(trade.return, 2)}</td>
        <td>${trade.hold}d</td>
      </tr>`;
    }).join("");
  }

  function renderSummary() {
    document.getElementById("updated").textContent = `${t("updatedPrefix")}: ${signal.updated_at_utc}`;
    document.getElementById("action").textContent = signal.action;
    document.getElementById("confidence").textContent = signal.confidence;
    document.getElementById("scoreTotal").textContent = fmt(signal.score_total, 0);
    document.getElementById("scorePrice").textContent = fmt(signal.breakdown.score_price, 0);
    document.getElementById("scoreCOT").textContent = fmt(signal.breakdown.score_cot, 0);
    document.getElementById("lastClose").textContent = fmt(signal.price.last_close, 2);
    document.getElementById("mas").textContent = `${t("maLabel")}: ${fmt(signal.price.ma20,2)} / ${fmt(signal.price.ma50,2)} / ${fmt(signal.price.ma200,2)}`;
    document.getElementById("mom").textContent = fmt(signal.price.mom_1m_pct, 2);
    const edgeText = `Edge score ${fmt(signal.score_total, 0)}`;
    document.getElementById("edgeScore").textContent = edgeText;
    const regime = signal.price.ma50 > signal.price.ma200 ? "Trending Up" : signal.price.ma20 > signal.price.ma50 ? "Range / Pullback" : "Trending Down";
    document.getElementById("regimeTag").textContent = regime;
    document.getElementById("edgeTag").textContent = `Edge ${signal.confidence}`;

    if (cot.cot_available) {
      document.getElementById("cotLine").textContent = `Report ${cot.cot_report_date}, nc_net=${fmt(cot.nc_net,0)}, Δ4w=${fmt(cot.nc_net_delta_4w,0)}, pct=${fmt(cot.nc_net_percentile,1)}`;
    } else { document.getElementById("cotLine").textContent = t("cotUnavailable"); }

    if (edgar.edgar_available && edgar.latest_filing) {
      document.getElementById("edgarLine").textContent = `${edgar.latest_filing.form} @ ${edgar.latest_filing.filingDate} (days_ago=${edgar.latest_filing.days_ago})`;
    } else if (edgar.edgar_available) { document.getElementById("edgarLine").textContent = t("edgarNoFiling"); }
    else { document.getElementById("edgarLine").textContent = t("edgarUnavailable"); }

    document.getElementById("perfSummaryUpdated").textContent = perfSummary.updated_at || "—";
    document.getElementById("perfSummaryUpdated2").textContent = perfSummary.updated_at || "—";
    const algoScore = perfSummary.algo_score || {};
    const algoComposite = algoScore.composite ?? algoScore.score ?? null;
    document.getElementById("algoScore").textContent = fmt(algoComposite, 0);
    const hit = fmtPct(algoScore.hit_rate ?? perfSummary.hit_rate, 0);
    const sharpe = fmt(algoScore.sharpe_ratio, 2);
    const cycle = fmtPct(algoScore.cycle_capture_rate, 0);
    document.getElementById("algoScoreMeta").textContent = `${t("hitRateLabel")}: ${hit} · ${t("sharpeLabel")}: ${sharpe} · ${t("cycleCaptureLabel")}: ${cycle}`;
    document.getElementById("hitRate").textContent = fmtPct(perfSummary.hit_rate, 0);
    document.getElementById("avgReturn5d").textContent = fmtPct(perfSummary.avg_return_5d, 2);
    document.getElementById("avgReturn10d").textContent = fmtPct(perfSummary.avg_return_10d, 2);
    document.getElementById("maxDrawdown").textContent = fmtPct(perfSummary.max_drawdown, 2);

    document.getElementById("decompUpdated").textContent = decomposition.updated_at || "—";
    document.getElementById("decompPeriod").textContent = decomposition.period ?? "—";
  }

  function renderDecomposition(range) {
    const months = range === "3m" ? 3 : range === "1y" ? 12 : null;
    const mask = getRangeMask(months, state.startDate, state.endDate);
    const dates = applyMask(prices.dates, mask);
    const trend = applyMask(decomposition.trend ?? [], mask);
    const seasonal = applyMask(decomposition.seasonal ?? [], mask);
    const residual = applyMask(decomposition.residual ?? [], mask);

    if (!trend.length) {
      document.getElementById("trendChart").textContent = t("decompUnavailable");
      document.getElementById("seasonalChart").textContent = t("decompUnavailable");
      return;
    }

    const layout = { paper_bgcolor: "rgba(0,0,0,0)", plot_bgcolor: "rgba(0,0,0,0)", margin: { l: 45, r: 15, t: 10, b: 30 }, xaxis: { showgrid: false, color: "#a8b4d6" }, yaxis: { showgrid: true, gridcolor: "#1e2a45", color: "#a8b4d6" } };
    Plotly.newPlot("trendChart", [{ x: dates, y: trend, mode: "lines", name: t("trendTitle"), line: { color: "#4c9cff" } }], layout, { displayModeBar: false });
    Plotly.newPlot("seasonalChart", [
      { x: dates, y: seasonal, mode: "lines", name: t("seasonalTitle"), line: { color: "#fbbf24" } },
      { x: dates, y: residual, mode: "lines", name: "Residual", line: { color: "#a855f7", dash: "dot" } },
    ], layout, { displayModeBar: false });
  }

  function renderAll() {
    applyLanguage();
    renderMeta();
    renderSummary();
    renderPrice(state.range);
    renderEquity(state.range);
    renderTradeLog();
    renderDecomposition(state.range);
  }

  renderAll();

  document.querySelectorAll('.btn[data-range]').forEach((btn) => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.btn[data-range]').forEach((b) => b.classList.remove('active'));
      btn.classList.add('active');
      state.range = btn.dataset.range;
      renderAll();
    });
  });

  document.getElementById("toggleMa").addEventListener("change", (e) => { state.showMa = e.target.checked; renderPrice(state.range); });
  document.getElementById("toggleBoll").addEventListener("change", (e) => { state.showBoll = e.target.checked; renderPrice(state.range); });
  document.getElementById("toggleSignals").addEventListener("change", (e) => { state.showSignals = e.target.checked; renderPrice(state.range); });

  document.getElementById("langToggle").addEventListener("click", () => { state.lang = state.lang === "he" ? "en" : "he"; localStorage.setItem("lang", state.lang); renderAll(); });

  document.getElementById("toggleSettings").addEventListener("click", () => {
    const panel = document.getElementById("settingsPanel");
    const visible = panel.style.display === "grid";
    panel.style.display = visible ? "none" : "grid";
    document.getElementById("toggleSettings").textContent = visible ? t("openSettings") : "Close";
  });

  const startInput = document.getElementById("startDate");
  const endInput = document.getElementById("endDate");
  startInput.value = state.startDate.slice(0, 10);
  endInput.value = state.endDate.slice(0, 10);

  const syncDates = () => {
    const startDate = new Date(state.startDate);
    const endDate = new Date(state.endDate);
    if (startDate > endDate) { state.endDate = state.startDate; endInput.value = state.endDate.slice(0, 10); }
  };

  startInput.addEventListener("change", (e) => { state.startDate = e.target.value || state.startDate; syncDates(); renderAll(); });
  endInput.addEventListener("change", (e) => { state.endDate = e.target.value || state.endDate; syncDates(); renderAll(); });

  document.getElementById("costsInput").addEventListener("input", (e) => { state.costBps = Number(e.target.value) || 0; renderEquity(state.range); });
  document.getElementById("maWindowInput").addEventListener("input", (e) => { state.maWindow = Number(e.target.value) || state.maWindow; renderEquity(state.range); renderTradeLog(); });
  document.getElementById("rsiPeriodInput").addEventListener("input", (e) => { state.rsiPeriod = Number(e.target.value) || state.rsiPeriod; renderEquity(state.range); renderTradeLog(); });
  document.getElementById("rsiOversoldInput").addEventListener("input", (e) => { state.rsiOversold = Number(e.target.value) || state.rsiOversold; renderEquity(state.range); renderTradeLog(); });
  document.getElementById("rsiOverboughtInput").addEventListener("input", (e) => { state.rsiOverbought = Number(e.target.value) || state.rsiOverbought; renderEquity(state.range); renderTradeLog(); });
  document.getElementById("bandWindowInput").addEventListener("input", (e) => { state.bandWindow = Number(e.target.value) || state.bandWindow; renderEquity(state.range); renderTradeLog(); });
  document.getElementById("bandStdInput").addEventListener("input", (e) => { state.bandStd = Number(e.target.value) || state.bandStd; renderEquity(state.range); renderTradeLog(); });
  document.querySelectorAll('input[name="equityMode"]').forEach((r) => {
    r.addEventListener('change', (e) => { state.showNet = e.target.value === 'net'; renderEquity(state.range); });
  });
  document.querySelectorAll('input[name="pnltoggle"]').forEach((r) => {
    r.addEventListener('change', (e) => { state.showNet = e.target.value === 'net'; document.querySelector('input[name="equityMode"][value="'+(state.showNet?'net':'gross')+'"]').checked = true; renderEquity(state.range); });
  });
})();
</script>
</body>
</html>
