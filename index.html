<!doctype html>
<html lang="he">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SLV Monitor</title>
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <style>
    :root {
      --bg: #0b0f17;
      --card: #111a2b;
      --border: #1e2a45;
      --muted: #a8b4d6;
      --text: #e8eefc;
      --accent: #4c9cff;
      --success: #22c55e;
      --danger: #f43f5e;
    }
    body { font-family: system-ui, Arial; margin: 0; background: var(--bg); color: var(--text); }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 24px; }
    .row { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 16px; }
    .stack { display: grid; gap: 12px; }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; padding: 16px; }
    .subcard { background: #0d1424; border: 1px solid var(--border); border-radius: 12px; padding: 14px; }
    .big { font-size: 28px; font-weight: 800; }
    .muted { color: var(--muted); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .alert { margin-top: 10px; background: rgba(255, 159, 64, 0.12); border: 1px solid #ff9f40; color: #ffd7a2; padding: 10px 12px; border-radius: 10px; line-height: 1.5; }
    .alert-card { margin-top: 10px; background: #0d1424; border: 1px solid var(--border); border-radius: 12px; padding: 10px 12px; }
    .alert-card .title { font-weight: 700; }
    .action-meta { display: flex; gap: 16px; flex-wrap: wrap; font-size: 14px; color: var(--muted); margin: 6px 0 10px; }
    .action-badge { padding: 6px 12px; border-radius: 10px; border: 1px solid var(--border); font-weight: 800; letter-spacing: 0.5px; }
    .action-badge.positive { background: rgba(34, 197, 94, 0.14); color: var(--success); }
    .action-badge.negative { background: rgba(244, 63, 94, 0.16); color: var(--danger); }
    .action-badge.neutral { background: rgba(255,255,255,0.08); color: var(--text); }
    .action-score-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; margin: 10px 0; }
    .score-block { background: #0d1424; border: 1px solid var(--border); border-radius: 10px; padding: 10px; }
    .score-block .label { font-size: 12px; color: var(--muted); }
    .score-block .value { font-size: 20px; font-weight: 700; margin-top: 4px; }
    .action-breakdown { display: grid; gap: 8px; margin-top: 8px; }
    .breakdown-row { display: grid; grid-template-columns: 1.4fr 0.6fr 3fr; gap: 8px; align-items: center; background: #0d1424; border: 1px solid var(--border); border-radius: 10px; padding: 8px 10px; }
    .breakdown-name { font-weight: 700; }
    .breakdown-points { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; text-align: right; color: var(--muted); }
    .breakdown-summary { color: var(--muted); font-size: 13px; }
    .action-breakdown-panel summary, .action-rationale summary, .action-backtest summary { cursor: pointer; font-weight: 700; }
    .action-rationale, .action-breakdown-panel, .action-backtest { background: #0d1424; border: 1px solid var(--border); border-radius: 10px; padding: 10px; margin: 10px 0; }
    .rationale-headline { font-weight: 700; margin-bottom: 6px; }
    .action-disclaimer { margin-top: 10px; display: flex; gap: 8px; align-items: flex-start; font-size: 13px; color: #fbbf24; }
    .warning-icon { font-size: 16px; }
    .tooltip-bubble { position: fixed; z-index: 9999; background: #111a2b; color: var(--text); border: 1px solid var(--border); border-radius: 8px; padding: 8px 10px; font-size: 12px; max-width: 260px; box-shadow: 0 10px 25px rgba(0,0,0,0.35); }
    .tooltip-title { font-weight: 700; margin-bottom: 4px; color: #e8eefc; }
    .tooltip-body { color: var(--text); line-height: 1.5; }
    .tooltip-link { margin-top: 8px; text-align: right; }
    .tooltip-link a { color: var(--accent); font-weight: 700; text-decoration: none; }
    [data-tooltip], [data-glossary] { cursor: help; }
    .badge-inline { display: inline-block; padding: 2px 8px; border-radius: 999px; font-size: 12px; margin-inline-end: 6px; border: 1px solid var(--border); }
    .sev-info { background: rgba(76, 156, 255, 0.15); color: #8bb2ff; }
    .sev-warn { background: rgba(255, 159, 64, 0.18); color: #ffb86c; }
    .sev-critical { background: rgba(244, 63, 94, 0.2); color: #f43f5e; }
    .kpis { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-top: 12px; }
    .kpi { background: #0d1424; border: 1px solid var(--border); border-radius: 12px; padding: 10px; }
    .kpi .v { font-size: 18px; font-weight: 700; margin-top: 4px; }
    .kpi .small { font-size: 12px; color: var(--muted); margin-top: 4px; display: block; line-height: 1.4; }
    .kpi.highlight { border-color: rgba(34, 197, 94, 0.5); box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.25); }
    .pill { display: inline-block; padding: 4px 10px; border-radius: 999px; font-size: 13px; border: 1px solid var(--border); text-transform: uppercase; letter-spacing: 0.5px; }
    .pill.up { background: rgba(34, 197, 94, 0.12); color: var(--success); }
    .pill.down { background: rgba(244, 63, 94, 0.12); color: var(--danger); }
    .pill.neutral { background: rgba(255,255,255,0.06); color: var(--text); }
    .pill.fresh { background: rgba(34, 197, 94, 0.14); color: var(--success); }
    .pill.recent { background: rgba(255,255,255,0.08); color: var(--text); }
    .pill.stale { background: rgba(244, 63, 94, 0.18); color: var(--danger); }
    .controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; margin: 12px 0 8px; }
    .btn { background: #0d1424; color: var(--text); border: 1px solid var(--border); border-radius: 10px; padding: 6px 10px; cursor: pointer; }
    .btn.active { background: #1f2d4a; border-color: var(--accent); }
    .toggle { display: inline-flex; gap: 6px; align-items: center; padding: 6px 10px; background: #0d1424; border: 1px solid var(--border); border-radius: 10px; cursor: pointer; }
    .toggle input { accent-color: var(--accent); }
    .header-top { display: flex; justify-content: space-between; gap: 12px; flex-wrap: wrap; }
    .header-actions { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .header-content { flex: 1; min-width: 0; }
    #langSelect { width: auto; min-width: 120px; }
    .meta-row { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    .badge { display: inline-block; padding: 4px 8px; border-radius: 8px; background: rgba(255,255,255,0.06); font-size: 12px; margin-right: 6px; }
    .badge.soft { background: rgba(99, 102, 241, 0.12); color: #c7d2fe; border: 1px solid var(--border); }
    .section-title { font-size: 18px; font-weight: 700; display: flex; align-items: center; gap: 8px; }
    .chip { padding: 4px 8px; border-radius: 999px; border: 1px solid var(--border); font-size: 12px; }
    .chip.muted { background: rgba(255,255,255,0.06); color: var(--muted); }
    .chip.info { background: rgba(76, 156, 255, 0.15); color: #8bb2ff; }
    .table { width: 100%; border-collapse: collapse; margin-top: 8px; font-size: 14px; }
    .table th, .table td { padding: 8px; text-align: right; border-bottom: 1px solid var(--border); }
    .table th { color: var(--muted); font-weight: 700; }
    .table td { color: var(--text); }
    body[dir="ltr"] .table th, body[dir="ltr"] .table td { text-align: left; }
    .flex { display: flex; align-items: center; gap: 8px; }
    .space { flex: 1; }
    .settings { background: rgba(255,255,255,0.03); border-radius: 12px; padding: 12px; margin-top: 10px; display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 12px; }
    label.small { font-size: 12px; color: var(--muted); display: block; margin-bottom: 6px; }
    input, select { width: 100%; padding: 8px 10px; border-radius: 10px; border: 1px solid var(--border); background: #0d1424; color: var(--text); }
    .subtitle { font-size: 14px; color: var(--muted); margin-top: 4px; }
    .cost-impact { margin-top: 10px; background: rgba(255,255,255,0.04); border: 1px solid var(--border); border-radius: 12px; padding: 10px; color: var(--muted); font-size: 13px; line-height: 1.5; }
    .cost-impact strong { color: var(--text); }
    .state-dot { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-inline-end: 6px; }
    .dot-bull { background: var(--success); }
    .dot-bear { background: var(--danger); }
    .dot-neutral { background: #a8b4d6; }
    .evidence-list { margin: 10px 0 0; padding: 0 0 0 18px; color: var(--muted); line-height: 1.6; }
    .grid-2 { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 12px; }
    .range-chip { background: rgba(255,255,255,0.06); padding: 6px 10px; border-radius: 10px; display: inline-flex; gap: 8px; align-items: center; }
    .analogy { background: #0d1424; border: 1px solid var(--border); border-radius: 10px; padding: 10px; margin-top: 8px; }
    .panel-label { font-size: 13px; letter-spacing: 0.5px; text-transform: uppercase; color: var(--muted); }
    .mini-bar { position: relative; height: 40px; margin-top: 12px; background: #0d1424; border: 1px solid var(--border); border-radius: 12px; overflow: hidden; }
    .mini-track { position: absolute; top: 50%; left: 0; right: 0; height: 6px; background: linear-gradient(90deg, #1d4ed8, #60a5fa, #6b7280, #fb923c, #ef4444); transform: translateY(-50%); opacity: 0.8; }
    .mini-pointer { position: absolute; top: 6px; width: 2px; height: 28px; background: #fff; border-radius: 2px; box-shadow: 0 0 6px rgba(255,255,255,0.6); transition: left 0.2s ease; }
    .mini-label { position: absolute; top: 6px; font-size: 11px; color: var(--muted); padding: 2px 6px; background: rgba(255,255,255,0.04); border: 1px solid var(--border); border-radius: 8px; }
    .mini-label.left { left: 6px; }
    .mini-label.right { right: 6px; }
    .band-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 8px; margin-top: 12px; }
    .band-card { background: #0d1424; border: 1px solid var(--border); border-radius: 12px; padding: 10px; }
    .band-card .title { font-weight: 700; margin-bottom: 6px; display: flex; align-items: center; gap: 6px; }
    .band-card .stat { font-size: 14px; line-height: 1.5; color: var(--muted); }
    .pill.extreme-high { background: rgba(239, 68, 68, 0.16); color: #f87171; }
    .pill.high { background: rgba(248, 180, 0, 0.16); color: #fbbf24; }
    .pill.neutral { background: rgba(255,255,255,0.08); color: var(--text); }
    .pill.low { background: rgba(96, 165, 250, 0.18); color: #93c5fd; }
    .pill.extreme-low { background: rgba(37, 99, 235, 0.18); color: #bfdbfe; }
    .cot-grid { display: grid; gap: 10px; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); margin-top: 10px; }
    .cot-row { background: #0d1424; border: 1px solid var(--border); border-radius: 10px; padding: 10px; }
    .cot-label { font-weight: 700; margin-bottom: 4px; }
    .cot-value { font-size: 18px; }
    .cot-sub { font-size: 12px; }
    .cot-foot { margin-top: 10px; display: grid; gap: 4px; }
    .heatmap-legend { display: flex; gap: 8px; align-items: center; margin-top: 8px; color: var(--muted); font-size: 12px; flex-wrap: wrap; }
    .legend-swatch { width: 14px; height: 14px; border-radius: 4px; display: inline-block; border: 1px solid var(--border); }
    .legend-item { display: inline-flex; align-items: center; gap: 6px; padding: 4px 6px; background: rgba(255,255,255,0.03); border: 1px solid var(--border); border-radius: 10px; }
    .context-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 12px; margin-top: 10px; }
    .context-item-card { background: #0d1424; border: 1px solid var(--border); border-radius: 12px; padding: 12px; display: flex; flex-direction: column; gap: 10px; }
    .context-row { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 8px; }
    .context-name { font-weight: 700; }
    .stat-block { flex: 1; min-width: 120px; }
    .stat-label { font-size: 12px; color: var(--muted); }
    .stat-value { font-size: 16px; font-family: monospace; }
    .stat-pair { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 8px; width: 100%; }
    .context-low-confidence { opacity: 0.82; }
    .context-note { color: var(--muted); font-size: 13px; line-height: 1.5; margin-top: 6px; }
    .context-warning { color: #fbbf24; font-size: 12px; line-height: 1.5; }
    .context-warning { color: #fbbf24; font-size: 12px; }
    .rule-checks { display: flex; flex-direction: column; gap: 8px; margin-top: 8px; }
    .rule-check { display: flex; gap: 10px; padding: 8px 10px; border-radius: 10px; background: rgba(255,255,255,0.03); border: 1px solid var(--border); }
    .rule-check.pass { border-color: rgba(34, 197, 94, 0.3); }
    .rule-check.fail { border-color: rgba(244, 63, 94, 0.35); }
    .rule-check.na { border-color: rgba(148, 163, 184, 0.4); opacity: 0.94; }
    .rule-check .marker { font-size: 18px; }
    .rules-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; margin-top: 10px; }
    .plain-list { list-style: none; padding: 0; margin: 0; display: grid; gap: 6px; color: var(--muted); }
    .plain-list li { padding-left: 0; }
    .success-flag { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 10px; border: 1px solid rgba(34,197,94,0.35); background: rgba(34,197,94,0.12); color: var(--success); font-weight: 700; margin-top: 10px; }
    @media (max-width: 900px) {
      .wrap { padding: 18px; }
      .row { grid-template-columns: 1fr; }
      .header-top { flex-direction: column; align-items: flex-start; }
    }

    @media (max-width: 640px) {
      .wrap { padding: 14px; }
      .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); align-items: start; }
      .controls .space { display: none; }
      .kpis { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); }
      .context-grid, .grid-2, .band-grid, .settings { grid-template-columns: 1fr; }
      .stat-pair { grid-template-columns: 1fr; }
      .header-top select { width: 100%; }
    }
    a { color: #8bb2ff; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="header-top">
        <div class="header-content">
          <div class="big" data-i18n="title">SLV Monitor</div>
          <div class="muted" data-i18n="subtitle">×“×©×‘×•×¨×“ ×¡×˜×˜×™ ×‘-GitHub Pages + â€œ××•×—â€ ×©×¨×¥ ×‘-GitHub Actions ×•××¢×“×›×Ÿ JSON.</div>
          <div class="muted mono" id="updated">Loadingâ€¦</div>
          <div id="global-status" style="margin:10px 0;"></div>
          <div id="data-status" style="margin:10px 0; font-size: 12px; opacity: 0.9;"></div>
          <div class="meta-row">
            <span class="badge"><span data-i18n="metaSourceLabel">Data source</span>: <span class="mono" id="metaSource">â€”</span></span>
            <span class="badge"><span data-i18n="metaCoverageLabel">Coverage</span>: <span class="mono" id="metaCoverage">â€”</span></span>
            <span class="badge"><span data-i18n="metaUpdatedLabel">Last updated</span>: <span class="mono" id="metaUpdated">â€”</span></span>
            <span class="badge"><span data-i18n="metaSnapshotStatusLabel">Snapshot status</span>: <span class="mono" id="metaSnapshotStatus">â€”</span></span>
            <span class="badge"><span data-i18n="metaSnapshotAgeLabel">Snapshot age</span>: <span class="mono" id="metaSnapshotAge">â€”</span></span>
            <span class="badge soft" id="eventContextBadge">â€”</span>
          </div>
          <div class="context-warning" id="metaSnapshotNote" style="display:none;"></div>
        </div>
        <div class="header-actions">
          <button class="btn" id="howItWorksBtn" type="button" data-i18n="howItWorksLabel">â„¹ï¸ ××™×š ×–×” ×¢×•×‘×“?</button>
          <button class="btn" id="advancedShortcut" type="button" data-i18n="advancedShortcut">Advanced Analysis</button>
          <select class="btn" id="langSelect" aria-label="Switch language"></select>
        </div>
      </div>
      <div class="alert" data-i18n="alert">
        ×”××œ×¦×•×ª ×”××¢×¨×›×ª ×”×Ÿ ×ª×•×¦××” ×©×œ ×¢×™×‘×•×“ ×¡×˜×˜×™×¡×˜×™ ×•××™× ×Ÿ ××”×•×•×ª ×™×™×¢×•×¥ ××• ×”× ×—×™×” ×œ×‘×™×¦×•×¢ ×¤×¢×•×œ×” ××™×™×“×™×ª. ××•××œ×¥ ×œ×©×œ×‘ ××ª ×”××™×ª×•×ª×™× ×¢× ×’×•×¨××™× × ×•×¡×¤×™× ×›××• ×—×“×©×•×ª ×××§×¨×•, ××“×™× ×™×•×ª ××•× ×™×˜×¨×™×ª ×•×©×™×§×•×œ×™× ××™×©×™×™× ××—×¨×™×.
      </div>
    </div>

    <div style="height:16px"></div>

    <div class="row">
      <div class="card" id="snapshotCard">
        <div class="section-title flex">
          <span data-i18n="marketSnapshotTitle">Market Snapshot</span>
          <span class="pill neutral" id="biasBadge">â€”</span>
          <span class="pill neutral" id="volBadge">â€”</span>
        </div>
          <div class="muted" id="scenarioId">â€”</div>
          <div class="big" id="probHeadline">â€”</div>
          <div class="subtitle" id="probSubtext">â€”</div>
        <div class="kpis">
          <div class="kpi">
            <div class="muted" data-i18n="confidenceLabel">Confidence</div>
            <div class="v mono" id="probConfidence">â€”</div>
          </div>
          <div class="kpi">
            <div class="muted" data-i18n="occurrencesLabel">Occurrences</div>
            <div class="v mono" id="probOccurrences">â€”</div>
            <span class="small" id="probDisclaimer">â€”</span>
          </div>
          <div class="kpi">
            <div class="muted" data-i18n="historicalRangeLabel">Common range (5d)</div>
            <div class="v mono" id="probRange">â€”</div>
            <span class="small" id="probMedian">â€”</span>
          </div>
        </div>
        <div class="muted" id="historicalSentence">â€”</div>
        <ul class="evidence-list" id="probEvidence"></ul>
      </div>

      <div class="card" id="outcomesCard">
        <div class="section-title" data-i18n="whatItMeansTitle">What this usually means</div>
        <div class="kpis">
          <div class="kpi">
            <div class="muted">P(up 5d)</div>
            <div class="v mono" id="probUp">â€”</div>
            <span class="small" data-i18n="limitsCopy">×”× ×ª×•× ×™× ×”×™×¡×˜×•×¨×™×™× ×‘×œ×‘×“; ×œ× ×”×ª×—×™×™×‘×•×ª ×œ×ª×•×¦××”.</span>
          </div>
          <div class="kpi">
            <div class="muted">P(down 5d)</div>
            <div class="v mono" id="probDown">â€”</div>
            <span class="small" id="probState">â€”</span>
          </div>
          <div class="kpi">
            <div class="muted" data-i18n="medianLabel">Median 5d</div>
            <div class="v mono" id="probMedianReturn">â€”</div>
            <span class="small" id="probSpread">â€”</span>
          </div>
        </div>
        <div class="range-chip" id="rangeChip"></div>
      </div>
    </div>

    <div style="height:16px"></div>

    <div class="card" id="eventContextCard">
      <div class="section-title flex">
        <span data-i18n="eventContextTitle">Event Context</span>
        <span class="chip muted" id="eventPhaseChip">â€”</span>
        <span class="chip info" id="eventPriorityChip">â€”</span>
      </div>
      <div class="context-note" id="eventContextSummary">â€”</div>
      <div class="context-grid">
        <div class="kpi">
          <div class="muted" data-i18n="eventNameLabel">Event</div>
          <div class="v mono" id="eventName">â€”</div>
          <span class="small" id="eventTiming">â€”</span>
        </div>
        <div class="kpi">
          <div class="muted" data-i18n="volImpactLabel">Volatility context</div>
          <div class="v mono" id="eventVolLabel">â€”</div>
          <span class="small" id="eventVolStats">â€”</span>
        </div>
        <div class="kpi">
          <div class="muted" data-i18n="directionalNoteLabel">Directional note</div>
          <div class="v mono" id="eventDirection">â€”</div>
          <span class="small" id="eventDirStats">â€”</span>
        </div>
      </div>
      <div class="context-grid">
        <div class="kpi">
          <div class="muted" data-i18n="eventProb1dLabel">1d outcomes</div>
          <div class="v mono" id="eventProb1d">â€”</div>
          <span class="small" id="eventMedian1d">â€”</span>
        </div>
        <div class="kpi">
          <div class="muted" data-i18n="eventProb5dLabel">5d outcomes</div>
          <div class="v mono" id="eventProb5d">â€”</div>
          <span class="small" id="eventMedian5d">â€”</span>
        </div>
      </div>
      <div class="context-note" id="eventContextFooter">â€”</div>
    </div>

    <div style="height:16px"></div>

    <div class="card" id="contextCard">
      <div class="section-title flex">
        <span data-i18n="contextTitle">Cross-Market Context</span>
        <span class="chip muted" id="contextAsOf">â€”</span>
      </div>
      <div class="context-note" data-i18n="contextNote">Dollar / gold / rates framing; not a signal.</div>
      <div class="context-note" id="contextMetaNote"></div>
      <div class="context-warning" id="contextWarnings" style="display:none;"></div>
      <div id="contextItems" class="context-grid"></div>
      <div class="context-note" id="contextFooter" data-i18n="contextFooter">Context only; not a trade idea.</div>
    </div>

    <div style="height:16px"></div>

    <div class="card" id="cotCard"></div>

    <div style="height:16px"></div>

    <div class="card" id="action-recommendation"></div>

    <div style="height:16px"></div>

    <div class="card" id="simpleRulesRecommendation"></div>

    <div style="height:16px"></div>

    <div class="card" id="simpleRulesExplain"></div>

    <div style="height:16px"></div>

    <div class="card" id="simpleRulesBacktest"></div>

    <div style="height:16px"></div>

    <div class="card" id="analogiesCard">
      <div class="section-title flex">
        <span data-i18n="analogiesTitle">Analogies</span>
        <span class="panel-label" data-i18n="analogiesNote">×“×•××™× ×”×™×¡×˜×•×¨×™×™× Â· ×œ×œ× ×”×•×¨××•×ª</span>
      </div>
      <div id="analogyList" class="grid-2"></div>
    </div>

    <div style="height:16px"></div>

    <div class="card" id="probEngineCard">
      <div class="section-title flex">
        <div class="flex" style="gap:8px; align-items:center;">
          <span data-i18n="probEngineTitle">Probability Engine</span>
          <span class="chip muted" id="probEngineConfidence">â€”</span>
        </div>
        <div class="controls" style="margin:0;">
          <button class="btn" id="probEngineInfoBtn" data-i18n="probEngineInfoLabel">ğŸ” ××™×“×¢</button>
          <button class="btn" id="probEngineSettingsToggle" data-i18n="probEngineSettingsLabel">Settings</button>
        </div>
      </div>
      <div class="settings" id="probEngineSettingsPanel" style="display:none;">
        <div>
          <label class="small" data-i18n="probEngineHorizonLabel">××•×¤×§ ×ª×—×–×™×ª</label>
          <select id="probSettingHorizon">
            <option value="5">5</option>
            <option value="20">20</option>
            <option value="60">60</option>
          </select>
        </div>
        <div>
          <label class="small" data-i18n="probEngineKLabel">K (×©×›× ×™×)</label>
          <select id="probSettingK">
            <option value="80">80</option>
            <option value="120">120</option>
            <option value="150">150</option>
            <option value="200">200</option>
          </select>
        </div>
        <div>
          <label class="small" data-i18n="probEngineWeightingLabel">×©×™×˜×ª ××©×§×•×œ×•×ª</label>
          <select id="probSettingWeighting">
            <option value="inverse_distance">Inverse distance</option>
            <option value="softmax">Softmax</option>
          </select>
        </div>
        <div>
          <label class="small" data-i18n="probEngineSuccessThresholdLabel">×¡×£ ×”×¦×œ×—×”</label>
          <select id="probSettingThreshold">
            <option value="0">0%</option>
            <option value="1">1%</option>
            <option value="2">2%</option>
          </select>
        </div>
        <div>
          <label class="small" data-i18n="probEngineHighlightLabel">×¡×£ ×”×“×’×©×” ×œ-P(up)</label>
          <input type="number" id="probSettingHighlight" min="0" max="100" step="1" />
        </div>
        <div style="align-self:end;">
          <button class="btn" id="probEngineApply" data-i18n="probEngineApplyLabel">×¢×“×›×•×Ÿ</button>
        </div>
      </div>
      <div class="kpis">
        <div class="kpi" id="probEngineProbWrap">
          <div class="muted" data-i18n="probEngineProbLabel">P(up)</div>
          <div class="v mono" id="probEngineProb">â€”</div>
          <span class="small" id="probEngineHorizon">â€”</span>
        </div>
        <div class="kpi">
          <div class="muted" data-i18n="probEngineMedianLabel">Median</div>
          <div class="v mono" id="probEngineMedian">â€”</div>
          <span class="small" id="probEngineRange">â€”</span>
        </div>
        <div class="kpi">
          <div class="muted" data-i18n="probEngineNeighborsLabel">Neighbors</div>
          <div class="v mono" id="probEngineNeighbors">â€”</div>
          <span class="small" id="probEngineDistance">â€”</span>
        </div>
      </div>
      <div class="success-flag" id="probEngineSuccessFlag" style="display:none;"></div>
      <div class="subtitle" id="probEngineDescription">â€”</div>
      <div id="probEngineTopNeighbors" class="grid-2"></div>
    </div>

    <div style="height:16px"></div>

    <div class="card" id="deviationPanel">
      <div class="section-title flex">
        <span data-i18n="deviationPanelTitle">Deviation vs history</span>
        <span class="pill neutral" id="bandStateTag">â€”</span>
      </div>
      <div class="muted" id="deviationMeta">â€”</div>
      <div class="kpis" style="margin-top:10px;">
        <div class="kpi">
          <div class="muted" data-i18n="zNowLabel">Z-score now</div>
          <div class="v mono" id="zNow">â€”</div>
          <span class="small" id="zWindowLabel">â€”</span>
        </div>
        <div class="kpi">
          <div class="muted" data-i18n="pctNowLabel">Percentile now</div>
          <div class="v mono" id="pctNow">â€”</div>
          <span class="small" id="pctWindowLabel">â€”</span>
        </div>
        <div class="kpi">
          <div class="muted" data-i18n="bandLabel">Band</div>
          <div class="v mono" id="bandLabelNow">â€”</div>
          <span class="small" id="bandHint">â€”</span>
        </div>
      </div>
      <div class="mini-bar" aria-label="z-score position">
        <div class="mini-track"></div>
        <div class="mini-pointer" id="zPointer"></div>
        <div class="mini-label left">-3Ïƒ</div>
        <div class="mini-label right">+3Ïƒ</div>
      </div>
      <div class="subtitle" id="bandContext">â€”</div>
    </div>

    <div style="height:16px"></div>

    <div class="card" id="heatmapCard">
      <div class="section-title flex">
        <span data-i18n="heatmapTitle">Heatmap timeline</span>
        <span class="panel-label" data-i18n="heatmapNote">×¡×˜×™×•×ª, ×ª× ×•×“×ª×™×•×ª, ××•×× ×˜×•× Â· ×œ×œ× BUY/SELL</span>
      </div>
      <div class="controls" style="margin-top:6px;">
        <div class="muted" data-i18n="viewLabel">View</div>
        <button class="btn active" data-heatmap="deviation" id="btnDeviation">Deviation</button>
        <button class="btn" data-heatmap="volatility" id="btnVolatility">Volatility</button>
        <button class="btn" data-heatmap="momentum" id="btnMomentum">Momentum</button>
        <span class="space"></span>
        <div class="muted" data-i18n="rangeLabel">×˜×•×•×— ×–××Ÿ:</div>
        <button class="btn" data-heatmap-range="3m">3M</button>
        <button class="btn" data-heatmap-range="1y">1Y</button>
        <button class="btn active" data-heatmap-range="all">All</button>
        <label class="toggle" style="margin-inline-start:8px;"><input type="checkbox" id="heatmapWeekly" /> <span data-i18n="weeklyAgg">Weekly</span></label>
      </div>
      <div id="heatmap" style="height:240px;"></div>
      <div class="heatmap-legend" id="heatmapLegend" aria-live="polite"></div>
      <div class="muted" id="heatmapNote">â€”</div>
      <div class="band-grid" id="bandStats"></div>
    </div>

    <div style="height:16px"></div>

    <div class="stack">
      <div class="card">
        <div class="section-title" data-i18n="anomalyNowTitle">Layer 1 Â· Alerts</div>
        <div class="muted" id="anomalyUpdated">â€”</div>
        <div class="flex" style="margin-top:8px; gap:12px;">
          <div>
            <div class="muted" data-i18n="anomalyScoreLabel">Anomaly score</div>
            <div class="big" id="anomalyScore">â€”</div>
          </div>
          <span class="pill neutral" id="trendTag">â€”</span>
          <span class="pill neutral" id="volTag">â€”</span>
        </div>
        <div class="kpis">
          <div class="kpi">
            <div class="muted" data-i18n="adxLabel">ADX</div>
            <div class="v mono" id="adxVal">â€”</div>
            <span class="small" id="trendNote">â€”</span>
          </div>
          <div class="kpi">
            <div class="muted" data-i18n="atrLabel">ATR (14)</div>
            <div class="v mono" id="atrVal">â€”</div>
            <span class="small" id="volNote">â€”</span>
          </div>
          <div class="kpi">
            <div class="muted" data-i18n="alertCountLabel">Active alerts</div>
            <div class="v mono" id="alertCount">â€”</div>
            <span class="small" id="topAlert">â€”</span>
          </div>
        </div>
        <div class="kpis">
          <div class="kpi">
            <div class="muted" data-i18n="latestCloseLabel">Latest Close</div>
            <div class="v mono" id="lastClose">â€”</div>
            <span class="small" id="mas">â€”</span>
          </div>
          <div class="kpi">
            <div class="muted" data-i18n="momLabel">1M Mom%</div>
            <div class="v mono" id="mom">â€”</div>
          </div>
        </div>
        <div class="section-title" style="margin-top:12px;" data-i18n="alertListTitle">What is unusual</div>
        <div id="alertsContainer"></div>
      </div>
    </div>

    <div style="height:16px"></div>

    <div class="card" id="advancedShell">
      <div class="flex" style="align-items:center; gap:12px;">
        <div class="header-content">
          <div class="section-title" id="advancedHeading" data-i18n="advancedClosedTitle">Advanced Analysis</div>
          <div class="subtitle" id="advancedSubtitle" data-i18n="advancedClosedSubtitle">Open charts, backtests and risk diagnostics.</div>
        </div>
        <span class="space"></span>
        <button class="btn" id="advancedToggle" aria-expanded="false" data-i18n="showAdvanced">Show Advanced Analysis</button>
      </div>
    </div>

    <div style="height:16px"></div>

    <div id="advancedPanel" style="display:none;">
      <div class="card" id="advancedAnalysisCard">
        <div class="section-title" data-i18n="advancedAnalysisTitle">Advanced Analysis</div>
        <div class="subtitle" data-i18n="advancedAnalysisSubtitle">Cycles, decomposition, equity vs benchmark, event context, cross-market context.</div>

        <div class="subcard">
          <div class="section-title" data-i18n="priceTitle">Price</div>
          <div class="controls">
            <div class="muted" data-i18n="rangeLabel">×˜×•×•×— ×–××Ÿ:</div>
            <button class="btn active" data-range="3m">3M</button>
            <button class="btn" data-range="1y">1Y</button>
            <button class="btn" data-range="all">All</button>
            <span class="space"></span>
            <label class="toggle"><input type="checkbox" id="toggleMa" checked /><span data-i18n="maToggle">MAs</span></label>
            <label class="toggle"><input type="checkbox" id="toggleBoll" checked /><span data-i18n="bollToggle">Bands</span></label>
            <label class="toggle"><input type="checkbox" id="toggleCycles" checked /><span data-i18n="cyclesToggle">Cycles</span></label>
          </div>
          <div id="chart" style="height:440px;"></div>
          <div class="muted" style="margin-top:8px;" data-i18n="cycleTitle">××—×–×•×¨×™ Peaks/Troughs ××—×¨×•× ×™×</div>
          <table class="table" id="cycleTable">
            <thead>
              <tr>
                <th data-i18n="cycleEndDate">×ª××¨×™×š ×¡×™×•×</th>
                <th data-i18n="cycleStartDate">×ª××¨×™×š ×”×ª×—×œ×”</th>
                <th data-i18n="cycleDirection">×›×™×•×•×Ÿ</th>
                <th data-i18n="cycleLength">××•×¨×š</th>
                <th data-i18n="cycleAmplitude">×××¤×œ×™×˜×•×“×”</th>
              </tr>
            </thead>
            <tbody>
              <tr><td colspan="5" class="muted">Loadingâ€¦</td></tr>
            </tbody>
          </table>
        </div>

        <div class="row" style="margin-top:12px;">
          <div class="subcard">
            <div class="section-title" data-i18n="equityTitle">Equity vs Benchmark (SLV)</div>
            <div class="controls" style="margin-top:6px;">
              <span class="muted" data-i18n="equityViewLabel">View:</span>
              <label class="toggle"><input type="radio" name="equityMode" value="gross" /> <span data-i18n="grossLabel">Gross</span></label>
              <label class="toggle"><input type="radio" name="equityMode" value="net" checked /> <span data-i18n="netLabel">Net (after cost)</span></label>
              <label class="toggle"><input type="checkbox" id="toggleFeesSensitivity" /> <span data-i18n="feesSensitivityLabel">Fees sensitivity</span></label>
              <span class="space"></span>
              <span class="muted" data-i18n="perfSummaryUpdatedLabel">×¢×•×“×›×Ÿ</span>: <span class="mono" id="perfSummaryUpdated">â€”</span>
            </div>
            <div class="cost-impact" id="costImpact">
              <div class="muted" data-i18n="feesImpactTitle">Fees impact</div>
              <div id="feesImpactBody">
                <div><span data-i18n="roundTripLabel">Round-trip</span>: <strong class="mono" id="roundTripBps">â€”</strong></div>
                <div><span data-i18n="tradesLabel">Trades</span>: <strong class="mono" id="numTrades">â€”</strong></div>
                <div><span data-i18n="feesTotalLabel">Total fees</span>: <strong class="mono" id="feesTotal">â€”</strong></div>
                <div><span data-i18n="feeDragLabel">Fee drag vs gross</span>: <strong class="mono" id="feeDragVal">â€”</strong></div>
                <div><span data-i18n="grossNetImpactLabel">Gross â†’ Net</span>: <span class="mono" id="grossReturnVal">â€”</span> â†’ <span class="mono" id="netReturnVal">â€”</span></div>
              </div>
              <div class="muted" id="feesNote"></div>
            </div>
            <div id="perfChart" style="height:320px;"></div>
            <table class="table" id="perfTable" style="margin-top:12px;">
              <thead>
                <tr>
                  <th data-i18n="seriesLabel">Series</th>
                  <th data-i18n="totalReturnLabel">Total Return</th>
                  <th data-i18n="maxDrawdownLabel">Max Drawdown</th>
                  <th data-i18n="sharpeLabel">Sharpe</th>
                  <th data-i18n="sortinoLabel">Sortino</th>
                </tr>
              </thead>
              <tbody id="perfTableBody">
                <tr><td colspan="5" class="muted">Loadingâ€¦</td></tr>
              </tbody>
            </table>
          </div>

          <div class="subcard">
            <div class="section-title" data-i18n="riskTitle">Risk metrics</div>
            <div class="kpis">
              <div class="kpi">
                <div class="muted" data-i18n="maxDrawdownLabel">Max Drawdown</div>
                <div class="v mono" id="riskDd">â€”</div>
              </div>
              <div class="kpi">
                <div class="muted" data-i18n="ulcerLabel">Ulcer Index</div>
                <div class="v mono" id="riskUlcer">â€”</div>
              </div>
              <div class="kpi">
                <div class="muted" data-i18n="worstMonthLabel">Worst Month</div>
                <div class="v mono" id="riskWorst">â€”</div>
              </div>
            </div>
            <div class="section-title" style="margin-top:16px;" data-i18n="tradeLogTitle">Trade log</div>
            <table class="table" id="tradeTable">
              <thead>
                <tr>
                  <th data-i18n="tradeEntry">Entry</th>
                  <th data-i18n="tradeExit">Exit</th>
                  <th data-i18n="tradeReason">Trigger</th>
                  <th data-i18n="tradeReturn">Return%</th>
                  <th data-i18n="tradeHold">Hold</th>
                </tr>
              </thead>
              <tbody>
                <tr><td colspan="5" class="muted">Loadingâ€¦</td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <div class="row" style="margin-top:12px;">
          <div class="subcard" id="performanceCard">
            <div class="section-title" data-i18n="performanceScoreTitle">×¦×™×•×Ÿ ×‘×™×¦×•×¢×™× ×›×•×œ×œ</div>
            <div class="muted"><span data-i18n="perfSummaryUpdatedLabel">×¢×•×“×›×Ÿ</span>: <span class="mono" id="perfSummaryUpdated2">â€”</span></div>
            <div class="kpis">
              <div class="kpi">
                <div class="muted" data-i18n="algoScoreLabel">×¦×™×•×Ÿ ××œ×’×•×¨×™×ª×</div>
                <div class="v mono" id="algoScore">â€”</div>
                <span class="small" id="algoScoreMeta">â€”</span>
              </div>
            </div>
            <div class="kpis">
              <div class="kpi">
                <div class="muted" data-i18n="hitRateLabel">Hit Rate</div>
                <div class="v mono" id="hitRate">â€”</div>
              </div>
              <div class="kpi">
                <div class="muted" data-i18n="avgReturn5dLabel">Avg Return 5d</div>
                <div class="v mono" id="avgReturn5d">â€”</div>
              </div>
              <div class="kpi">
                <div class="muted" data-i18n="avgReturn10dLabel">Avg Return 10d</div>
                <div class="v mono" id="avgReturn10d">â€”</div>
              </div>
              <div class="kpi">
                <div class="muted" data-i18n="maxDrawdownLabel">Max Drawdown</div>
                <div class="v mono" id="maxDrawdown">â€”</div>
              </div>
            </div>
          </div>

          <div class="subcard" id="decompCard">
            <div class="section-title" data-i18n="decompTitle">Decomposition</div>
            <div class="muted"><span data-i18n="decompUpdatedLabel">Updated</span>: <span class="mono" id="decompUpdated">â€”</span></div>
            <div class="muted"><span data-i18n="decompPeriodLabel">Period</span>: <span class="mono" id="decompPeriod">â€”</span></div>
            <div class="muted"><span data-i18n="decompInputLabel">Input</span>: <span class="mono" id="decompInput">â€”</span></div>
            <div class="muted" id="decompParams">â€”</div>
            <div class="alert-card" id="decompStatus" style="display:none"></div>
            <div id="trendChart" style="height:180px; margin-top:10px;"></div>
            <div id="seasonalChart" style="height:180px; margin-top:10px;"></div>
            <div id="residualChart" style="height:180px; margin-top:10px;"></div>
          </div>
        </div>
      </div>

      <div style="height:16px"></div>

      <div class="card" id="backtestSettingsCard">
        <div class="section-title flex">
          <span data-i18n="backtestSettings">Backtest Settings</span>
        </div>
        <div class="subtitle" data-i18n="backtestSettingsSubtitle">Adjust the backtest simulation parameters (not advice).</div>
        <div class="muted" data-i18n="simulationDisclaimer">Simulation only Â· Historical data Â· Not financial advice</div>
        <div class="settings" style="margin-top:10px;">
          <div>
            <label class="small" data-i18n="dateRangeLabel">Date range</label>
            <select id="dateRangeSelect">
              <option value="all" selected data-i18n="rangeAll">All</option>
              <option value="1y" data-i18n="range1Y">Last 1Y</option>
              <option value="3y" data-i18n="range3Y">Last 3Y</option>
              <option value="5y" data-i18n="range5Y">Last 5Y</option>
              <option value="custom" data-i18n="rangeCustom">Custom</option>
            </select>
          </div>
          <div id="customDateFields" class="stack" style="display:none;">
            <div>
              <label class="small" data-i18n="startDate">Start date</label>
              <input type="date" id="startDate" />
            </div>
            <div>
              <label class="small" data-i18n="endDate">End date</label>
              <input type="date" id="endDate" />
            </div>
          </div>
          <div>
            <label class="small" data-i18n="strategyPick">Strategy</label>
            <select id="strategySelect">
              <option value="cycle_basic" selected data-i18n="strategyCycleBasic">cycle_basic</option>
              <option value="risk_managed" data-i18n="strategyRiskManaged">risk_managed</option>
              <option value="buy_hold" data-i18n="strategyBuyHold">buy_hold</option>
            </select>
            <div class="small muted" data-i18n="strategyNote">Backtest uses confirmed signals only (no lookahead).</div>
          </div>
          <div>
            <label class="small" data-i18n="costsLabel">Costs (bps)</label>
            <input type="number" id="costsInput" min="0" step="1" value="10" />
          </div>
          <div>
            <label class="small" data-i18n="slippageLabel">Slippage (bps)</label>
            <input type="number" id="slippageInput" min="0" step="1" value="5" />
          </div>
          <div>
            <label class="small" data-i18n="grossNet">Gross / Net</label>
            <div class="flex">
              <label class="toggle"><input type="radio" name="pnlMode" value="gross" /> <span data-i18n="grossLabel">Gross</span></label>
              <label class="toggle"><input type="radio" name="pnlMode" value="net" checked /> <span data-i18n="netLabel">Net</span></label>
            </div>
          </div>
          <div>
            <label class="small" data-i18n="riskControlsLabel">Risk controls</label>
            <div class="stack">
              <label class="toggle"><input type="checkbox" id="useAtrSizing" /> <span data-i18n="useAtrSizing">Use ATR sizing</span></label>
              <div>
                <label class="small" data-i18n="targetDailyVol">Target daily vol (%)</label>
                <input type="number" id="targetDailyVol" step="0.1" value="1.0" min="0" />
              </div>
              <label class="toggle"><input type="checkbox" id="useStopLoss" /> <span data-i18n="useStopLoss">Use stop-loss</span></label>
              <div>
                <label class="small" data-i18n="stopAtrMult">Stop ATR multiple</label>
                <input type="number" id="stopAtrMult" step="0.1" value="2.5" min="0" />
              </div>
              <label class="toggle"><input type="checkbox" id="useTrailingStop" /> <span data-i18n="useTrailingStop">Enable trailing stop</span></label>
              <div>
                <label class="small" data-i18n="trailingAtrMult">Trailing ATR multiple</label>
                <input type="number" id="trailingAtrMult" step="0.1" value="3.0" min="0" />
              </div>
              <label class="toggle"><input type="checkbox" id="useVarSizing" /> <span data-i18n="useVarSizing">Size by VaR</span></label>
              <div class="grid-2">
                <div>
                  <label class="small" data-i18n="varConfidence">VaR confidence (%)</label>
                  <input type="number" id="varConfidence" step="1" value="95" min="50" max="99" />
                </div>
                <div>
                  <label class="small" data-i18n="varRisk">Risk budget per trade (%)</label>
                  <input type="number" id="varRisk" step="0.1" value="1.0" min="0" max="10" />
                </div>
                <div>
                  <label class="small" data-i18n="varLookback">VaR lookback (days)</label>
                  <input type="number" id="varLookback" step="5" value="60" min="20" max="400" />
                </div>
              </div>
            </div>
          </div>
          <div style="display:flex; align-items:flex-end;">
            <button class="btn" id="runSimulation" style="width:100%;" data-i18n="runSimulation">Run Simulation</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="card" id="tradingSimulationCard"></div>

<script type="module">
import { buildFeatureRows, knnAnalogProbability } from "./src/lib/probability-engine.js";
import { FetchAllCandidatesError } from "./src/lib/fetchJson.js";
import { createDataHub } from "./src/lib/data-hub.js";
import { injectCotIntoDaily } from "./src/lib/cot.js";
import { renderActionRecommendation } from "./src/ui/render-action-recommendation.js";
import { renderTradingSimulationCard } from "./src/ui/render-trading-simulation.js";
import { backtestRuleset } from "./src/lib/rules/backtest-ruleset.js";
import { renderRulesRecommendation, renderRulesExplain } from "./src/ui/render-rules-recommendation.js";
import { renderRulesBacktest } from "./src/ui/render-rules-backtest.js";
import { renderCotCard } from "./src/ui/render-cot.js";
import { attachTooltips } from "./src/ui/tooltips.js";

const HOW_IT_WORKS_BY_LANG = {
  he: "docs/how-it-works-he.html",
  en: "docs/how-it-works-en.html",
  es: "docs/how-it-works-es.html",
};

function getHowItWorksUrl(lang) {
  const url = HOW_IT_WORKS_BY_LANG[lang];
  return url || HOW_IT_WORKS_BY_LANG.en || HOW_IT_WORKS_BY_LANG.he;
}

function openHowItWorks(lang) {
  const url = getHowItWorksUrl(lang);
  window.open(url, "_blank", "noopener");
}

function setGlobalStatus(message, tone = "info") {
  const el = document.getElementById("global-status");
  if (!el) return;
  if (!message) { el.innerHTML = ""; return; }
  const styles = {
    info: { border: "#4c9cff", color: "#a8b4d6" },
    success: { border: "#22c55e", color: "#bbf7d0" },
    error: { border: "#f33", color: "#fca5a5" },
  };
  const { border, color } = styles[tone] || styles.info;
  el.innerHTML = `
    <div style="padding:12px;border:1px solid ${border};border-radius:10px;color:${color};background:rgba(15,23,42,0.6);">
      ${message}
      <div style="font-size:12px;color:#a8b4d6;">Check DevTools console for details.</div>
    </div>
  `;
}

function showGlobalError(message) {
  setGlobalStatus(`<b>Data load failed</b><br/>${message}`, "error");
}

const hub = createDataHub();
let dataErrors = {};

function escapeHtml(str) {
  return (str || "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

function renderCardError(rootId, title, error) {
  const root = document.getElementById(rootId);
  if (!root || !error) return;
  const details = error.details ? escapeHtml(JSON.stringify(error.details, null, 2)) : escapeHtml(error.message || "Unknown error");
  root.innerHTML = `
    <div class="section-title flex">${title}</div>
    <div class="alert-card">
      <div class="title">Failed to load data</div>
      <div class="muted">${escapeHtml(error.message || "")}</div>
      <details style="margin-top:8px;">
        <summary>Details</summary>
        <pre style="white-space:pre-wrap;">${details}</pre>
      </details>
    </div>
  `;
}

function renderDataStatusPanel(state) {
  const el = document.getElementById("data-status");
  if (!el) return;
  const errKeys = Object.keys(state.errors || {});
  const metaUrl = state.loadedFrom?.metaUrl || "â€”";
  const metaTimestamp = state.meta?.last_updated_utc || state.meta?.end || "â€”";
  el.innerHTML = `
    <div style="padding:10px;border:1px solid #1e2a45;border-radius:10px;background:rgba(255,255,255,0.02);">
      <b>Data Status</b><br/>
      Status: <b>${state.status}</b> | Loaded: ${state.progress.done}/${state.progress.total}<br/>
      meta: ${metaUrl !== "â€”" ? `<code>${metaUrl}</code>` : "â€”"}<br/>
      version: <code>${metaTimestamp}</code><br/>
      ${errKeys.length ? `Errors: <code>${errKeys.join(", ")}</code>` : "Errors: â€”"}
    </div>
  `;
}

function normalizePricesDataset(primary, legacy) {
  if (Array.isArray(primary)) {
    const cleaned = primary.filter((r) => r && r.date !== undefined && r.close !== undefined);
    if (cleaned.length) {
      return { dates: cleaned.map((r) => r.date ?? null), close: cleaned.map((r) => r.close ?? null) };
    }
  }

  if (legacy && Array.isArray(legacy.dates) && Array.isArray(legacy.close)) {
    return { dates: legacy.dates, close: legacy.close };
  }

  return { dates: [], close: [] };
}

function buildDecompositionFromDatasets(datasets) {
  const meta = datasets.decompositionMeta;
  const base = {
    status: meta?.status ?? (meta ? "ok" : "missing"),
    meta,
    trend: [],
    seasonal: [],
    residual: [],
    dates: [],
    error: meta?.error || (!meta ? "missing meta file" : null),
  };

  if (!meta || base.status !== "ok") return base;

  const mapSeries = (payload) => {
    const rows = Array.isArray(payload?.rows) ? payload.rows.filter((r) => r && r.date !== undefined) : [];
    return { dates: rows.map((r) => r.date ?? null), values: rows.map((r) => r.value ?? null) };
  };

  try {
    const trend = mapSeries(datasets.decompositionTrend);
    const seasonal = mapSeries(datasets.decompositionSeasonal);
    const residual = mapSeries(datasets.decompositionResidual);
    base.dates = trend.dates;
    base.trend = trend.values;
    base.seasonal = seasonal.values;
    base.residual = residual.values;
  } catch (err) {
    base.status = "error";
    base.error = err.message;
  }

  return base;
}

function detectLang() {
  const stored = localStorage.getItem("lang");
  if (stored && supportedLanguages.includes(stored)) return stored;

  const navCandidates = Array.isArray(navigator.languages) ? navigator.languages : [navigator.language || navigator.userLanguage || ""];
  for (const candidate of navCandidates) {
    const normalized = (candidate || "").toLowerCase().slice(0, 2);
    if (supportedLanguages.includes(normalized)) return normalized;
  }

  return "en";
}

const baseLanguageStrings = {
  he: {
    title: "×œ×•×— ×‘×§×¨×” ×œ-SLV",
    subtitle: "×“×©×‘×•×¨×“ ×¡×˜×˜×™ ×‘-GitHub Pages + â€œ××•×—â€ ×©×¨×¥ ×‘-GitHub Actions ×•××¢×“×›×Ÿ JSON.",
    howItWorksLabel: "××™×š ×–×” ×¢×•×‘×“?",
    howItWorksTooltip: "×¤×ª×— ×”×¡×‘×¨ ×¢×œ ×”×× ×•×¢ ×•×”×“×©×‘×•×¨×“",
    alert: "×”××œ×¦×•×ª ×”××¢×¨×›×ª ×”×Ÿ ×ª×•×¦××” ×©×œ ×¢×™×‘×•×“ ×¡×˜×˜×™×¡×˜×™ ×•××™× ×Ÿ ××”×•×•×ª ×™×™×¢×•×¥ ××• ×”× ×—×™×” ×œ×‘×™×¦×•×¢ ×¤×¢×•×œ×” ××™×™×“×™×ª. ××•××œ×¥ ×œ×©×œ×‘ ××ª ×”××™×ª×•×ª×™× ×¢× ×’×•×¨××™× × ×•×¡×¤×™× ×›××• ×—×“×©×•×ª ×××§×¨×•, ××“×™× ×™×•×ª ××•× ×™×˜×¨×™×ª ×•×©×™×§×•×œ×™× ××™×©×™×™× ××—×¨×™×.",
    priceTitle: "××—×™×¨",
    rangeLabel: "×˜×•×•×— ×–××Ÿ:",
    cycleTitle: "××—×–×•×¨×™ ×©×™×/×©×¤×œ ××—×¨×•× ×™×",
    cycleEndDate: "×ª××¨×™×š ×¡×™×•×",
    cycleStartDate: "×ª××¨×™×š ×”×ª×—×œ×”",
    cycleDirection: "×›×™×•×•×Ÿ",
    cycleLength: "××•×¨×š",
    cycleAmplitude: "×××¤×œ×™×˜×•×“×”",
    performanceScoreTitle: "×¦×™×•×Ÿ ×‘×™×¦×•×¢×™× ×›×•×œ×œ",
    perfSummaryUpdatedLabel: "×¢×•×“×›×Ÿ",
    equityTitle: "×ª×©×•××ª ××œ×’×• ××•×œ SLV",
    performanceTitle: "×‘×™×¦×•×¢×™×",
    feesImpactTitle: "×”×©×¤×¢×ª ×¢××œ×•×ª",
    feesSensitivityLabel: "×¨×’×™×©×•×ª ×œ×¢××œ×•×ª",
    roundTripLabel: "×¢×¡×§×” ×”×œ×•×š-×—×–×•×¨ (× ×§×•×“×•×ª ×‘×¡×™×¡)",
    tradesLabel: "××¡' ×¢×¡×§××•×ª",
    feesTotalLabel: "×¡×”\"×› ×¢××œ×•×ª",
    feeDragLabel: "×©×—×™×§×” ××•×œ ×ª×©×•××ª ×‘×¨×•×˜×•",
    noTradesFees: "××™×Ÿ ×˜×¨×™×™×“×™× â†’ ××™×Ÿ ×¢××œ×•×ª",
    algoScoreLabel: "×¦×™×•×Ÿ ××œ×’×•×¨×™×ª×",
    sharpeLabel: "××“×“ ×©××¨×¤",
    cycleCaptureLabel: "×¦×™×•×Ÿ ××—×–×•×¨×™",
    rsiLabel: "RSI (14)",
    stdLabel: "×¡×˜×™×™×ª ×ª×§×Ÿ ××ª×’×œ×’×œ×ª (20)",
    macdLabel: "MACD (12/26/9)",
    bollLabel: "×‘×•×œ×™× ×’×¨ (20, 2Ïƒ)",
    obvLabel: "OBV",
    maLongLabel: "MA1000",
    perfUpdatedLabel: "×¢×“×›×•×Ÿ ×‘×™×¦×•×¢×™×",
    decompTitle: "×¤×™×¨×•×§ (Decomposition)",
    decompUpdatedLabel: "×¢×“×›×•×Ÿ",
    decompPeriodLabel: "××•×¨×š ××—×–×•×¨",
    decompInputLabel: "×§×œ×˜",
    decompParamsLabel: "×¤×¨××˜×¨×™×",
    trendTitle: "××’××”",
    seasonalTitle: "×¢×•× ×ª×™×•×ª",
    residualTitle: "×©××¨×™×ª",
    noCycles: "×œ× ×–×•×”×• ××—×–×•×¨×™× ×¢×“×™×™×Ÿ.",
    perfSeriesUnavailable: "×¡×“×¨×ª ×‘×™×¦×•×¢×™× ×œ× ×–××™× ×”.",
    benchUnavailable: "×—×œ×•×Ÿ ××“×“ ×—×¡×¨.",
    decompUnavailable: "×¤×™×¨×•×§ ×œ× ×–××™×Ÿ.",
    decompMissing: "×¤×™×¨×•×§ ×œ× ×–××™×Ÿ (×§×‘×¦×™× ×—×¡×¨×™×).",
    seriesLabel: "×¡×“×¨×”",
    totalReturnLabel: "×ª×©×•××” ×›×•×œ×œ×ª",
    sortinoLabel: "××“×“ ×¡×•×¨×˜×™× ×•",
    strategyLabel: "××¡×˜×¨×˜×’×™×”",
    buyHoldLabel: "×§× ×™×™×” ×•×”×—×–×§×”",
    updatedPrefix: "×¢×•×“×›×Ÿ (UTC)",
    metaSourceLabel: "××§×•×¨ × ×ª×•× ×™×",
    metaCoverageLabel: "×˜×•×•×— ×›×™×¡×•×™",
    metaUpdatedLabel: "×¢×“×›×•×Ÿ ××—×¨×•×Ÿ",
    metaSnapshotStatusLabel: "×¡×˜×˜×•×¡ ×¡× ××¤×©×•×˜",
    metaSnapshotAgeLabel: "×’×™×œ ×¡× ××¤×©×•×˜",
    snapshotStatusLive: "×—×™",
    snapshotStatusCached: "×©××•×¨×”",
    snapshotStatusUnknown: "×œ× ×™×“×•×¢",
    snapshotErrorPrefix: "×©×’×™××ª ×¨×¢× ×•×Ÿ × ×ª×•× ×™×",
    marketSnapshotTitle: "×¦×™×œ×•× ××¦×‘ ×©×•×§",
    occurrencesLabel: "××¡×¤×¨ ××§×¨×™×",
    historicalRangeLabel: "×˜×•×•×— ×ª×•×¦××•×ª × ×¤×•×¥",
    whatItMeansTitle: "××” ×–×” ×‘×“×¨×š ×›×œ×œ ××•××¨",
    analogiesTitle: "×× ×œ×•×’×™×•×ª",
    analogiesNote: "×“×•××™× ×”×™×¡×˜×•×¨×™×™× Â· ×œ×œ× ×”×•×¨××•×ª",
    probEngineTitle: "×× ×•×¢ ×”×¡×ª×‘×¨×•×ª",
    probEngineInfoLabel: "ğŸ” ××™×“×¢",
    probEngineSettingsLabel: "×”×’×“×¨×•×ª",
    probEngineProbLabel: "×”×¡×ª×‘×¨×•×ª ×œ×¢×œ×™×™×”",
    probEngineMedianLabel: "×—×¦×™×•×Ÿ",
    probEngineNeighborsLabel: "×©×›× ×™×",
    probEngineRangeLabel: "×˜×•×•×—",
    probEngineConfidenceLow: "×‘×™×˜×—×•×Ÿ × ××•×š",
    probEngineConfidenceMedium: "×‘×™×˜×—×•×Ÿ ×‘×™× ×•× ×™",
    probEngineConfidenceHigh: "×‘×™×˜×—×•×Ÿ ×’×‘×•×”",
    probEngineHorizonLabel: "××•×¤×§ ×ª×—×–×™×ª (×™××™×)",
    probEngineKLabel: "K (××¡×¤×¨ ×©×›× ×™×)",
    probEngineWeightingLabel: "×©×™×˜×ª ××©×§×•×œ×•×ª",
    probEngineSuccessThresholdLabel: "×¡×£ ×”×¦×œ×—×” (×ª×©×•××” ××¢×œ)",
    probEngineHighlightLabel: "×”×“×’×©×” ×× P(up) ××¢×œ (%)",
    probEngineApplyLabel: "×¢×“×›×•×Ÿ",
    probEngineHighlightHit: "P(up) ×¢×‘×¨ ××ª ×¡×£ ×”×”×“×’×©×”",
    eventContextTitle: "×”×§×©×¨ ××™×¨×•×¢×™×",
    eventContextLabel: "×§×•× ×˜×§×¡×˜ ××™×¨×•×¢",
    eventContextNone: "××™×Ÿ ××™×¨×•×¢ ×§×¨×•×‘",
      contextTitle: "×”×§×©×¨ ×©×•×•×§×™× ×—×•×¦×”",
      contextNote: "×“×•×œ×¨ / ×–×”×‘ / ×¨×™×‘×™×•×ª Â· ×”×§×©×¨ ×”×™×¡×˜×•×¨×™ ×‘×œ×‘×“",
      contextFooter: "×”×§×©×¨ ×‘×œ×‘×“; ×œ× ×”×‘×˜×—×” ××• ×”× ×—×™×”.",
      contextHistLabel: "×”×™×¡×˜×•×¨×™×ª (5 ×™××™×)",
      contextHistFallback: "×—×¡×¨ ××“×’× ×”×™×¡×˜×•×¨×™ ××¡×¤×§",
      contextDisclaimer: "×”×§×©×¨ ×”×™×¡×˜×•×¨×™ ×‘×œ×‘×“; ×œ× ×”×‘×˜×—×”.",
      contextLowSample: "××“×’× ×§×˜×Ÿ; ×”×¡×§×” ×—×œ×©×”.",
      contextValueLabel: "×¢×¨×š × ×•×›×—×™",
      contextDateLabel: "×ª××¨×™×š ××—×¨×•×Ÿ",
      contextZLabel: "×¦×™×•×Ÿ Z",
      contextPctLabel: "××—×•×–×•×Ÿ",
      contextChangeLabel: "×©×™× ×•×™ ××•×œ ×”×ª×—×œ×”",
      contextSourceLabel: "××§×•×¨×•×ª",
      contextPUp5d: "×”×¡×ª×‘×¨×•×ª ×œ×¢×œ×™×™×” (5 ×™××™×)",
      contextMedian5d: "×—×¦×™×•×Ÿ 5 ×™××™×",
      contextPUp10d: "×”×¡×ª×‘×¨×•×ª ×œ×¢×œ×™×™×” (10 ×™××™×)",
      contextMedian10d: "×—×¦×™×•×Ÿ 10 ×™××™×",
    localTimeLabel: "×–××Ÿ ××§×•××™",
    freshLabel: "×¢×“×›× ×™",
    staleLabel: "Stale",
    recentLabel: "×¢×“×›×•×Ÿ ××—×¨×•×Ÿ",
    missingData: "×—×¡×¨ × ×ª×•×Ÿ",
    eventPhasePre: "×œ×¤× ×™ ××™×¨×•×¢",
    eventPhaseToday: "×™×•× ××™×¨×•×¢",
    eventPhasePost: "××—×¨×™ ××™×¨×•×¢",
    eventPhaseUpcoming: "××™×¨×•×¢ ××ª×•×–××Ÿ",
    eventNameLabel: "××™×¨×•×¢",
    volImpactLabel: "×”×§×©×¨ ×ª× ×•×“×ª×™×•×ª",
    directionalNoteLabel: "×›×™×•×•×Ÿ ×”×™×¡×˜×•×¨×™",
    eventProb1dLabel: "×ª×•×¦××•×ª ×™×•× ××™×¨×•×¢",
    eventProb5dLabel: "×ª×•×¦××•×ª 5 ×™××™×",
    sampleSizeLabel: "××“×’×",
    medianShortLabel: "×—×¦×™×•×Ÿ",
    eventContextFooter: "×”×§×©×¨ ×‘×œ×‘×“; ×œ× ×¡×™×’× ×œ ××• ×ª×—×–×™×ª.",
    eventTimingLabel: "××¨×—×§ ×œ×™×•× ××™×¨×•×¢",
    deviationPanelTitle: "×¡×˜×™×™×” ××•×œ ×”×™×¡×˜×•×¨×™×”",
    zNowLabel: "Z-score × ×•×›×—×™",
    pctNowLabel: "××—×•×–×•×Ÿ × ×•×›×—×™",
    bandLabel: "×¨×¦×•×¢×”",
    heatmapTitle: "××¤×ª ×—×•× ×œ××•×¨×š ×–××Ÿ",
    heatmapNote: "×”×¦×‘×¢ ×”×•× ×”×§×©×¨ ×‘×œ×‘×“; ×¨×—×¤×• ×›×“×™ ×œ×¨××•×ª ××¡×¤×¨×™×.",
    heatmapLegendTitle: "××§×¨× ×¦×‘×¢×™×",
    heatmapMeaningExtremeLowDeviation: "×”×¨×‘×” ××ª×—×ª ×œ×‘×¡×™×¡ (×¡×˜×™×™×ª ×—×¡×¨ ×—×“×”).",
    heatmapMeaningLowDeviation: "××ª×—×ª ×œ×‘×¡×™×¡ (×¡×˜×™×™×” ×©×œ×™×œ×™×ª).",
    heatmapMeaningNeutralDeviation: "×§×¨×•×‘ ×œ×‘×¡×™×¡ (×¡×˜×™×™×” × ××•×›×”).",
    heatmapMeaningHighDeviation: "××¢×œ ×”×‘×¡×™×¡ (×¡×˜×™×™×” ×—×™×•×‘×™×ª).",
    heatmapMeaningExtremeHighDeviation: "××¢×œ ×××•×“ ×œ×‘×¡×™×¡ (×¡×˜×™×™×ª ×™×ª×¨ ×—×“×”).",
    heatmapMeaningLowVol: "ATR% × ××•×š Â· ×ª× ×•×“×” ×™×•××™×ª ×¨×’×•×¢×” ××”×¨×’×™×œ.",
    heatmapMeaningNormalVol: "ATR% ×¨×’×™×œ Â· ×ª× ×•×“×ª×™×•×ª ×˜×™×¤×•×¡×™×ª.",
    heatmapMeaningHighVol: "ATR% ×’×‘×•×” Â· ×ª× ×•×“×ª×™×•×ª ××•×’×‘×¨×ª.",
    heatmapMeaningBearishMom: "ROC20 ×“×•×‘×™ Â· ×œ×—×¥ ×™×¨×™×“×•×ª.",
    heatmapMeaningNeutralMom: "ROC20 × ×™×˜×¨×œ×™ Â· ××•×× ×˜×•× ×©×˜×•×—.",
    heatmapMeaningBullishMom: "ROC20 ×©×•×¨×™ Â· ××•×× ×˜×•× ×¢×œ×™×•×ª.",
    heatmapTooltipDate: "×ª××¨×™×š",
    heatmapTooltipClose: "×¡×’×™×¨×”",
    heatmapTooltipZScore: "Z-score",
    heatmapTooltipPercentile: "××—×•×–×•×Ÿ",
    heatmapTooltipAtrPct: "ATR%",
    heatmapTooltipRoc20: "ROC20",
    heatmapTooltipMeaning: "××©××¢×•×ª",
    heatmapMissingData: "××™×Ÿ × ×ª×•× ×™× ×œ× ×§×•×“×” ×–×•.",
    viewLabel: "×ª×¦×•×’×”",
    weeklyAgg: "×©×‘×•×¢×™",
    limitsCopy: "×”× ×ª×•× ×™× ×”×™×¡×˜×•×¨×™×™× ×‘×œ×‘×“; ×œ× ×”×ª×—×™×™×‘×•×ª ×œ×ª×•×¦××”.",
    medianLabel: "×—×¦×™×•×Ÿ 5 ×™××™×",
    advancedTitle: "××¦×‘ ××ª×§×“×",
    advancedClosedTitle: "× ×™×ª×•×— ××ª×§×“×",
    advancedOpenTitle: "××¦×‘ ××ª×§×“× ×¤×ª×•×—",
    advancedClosedSubtitle: "×¤×ª×™×—×ª ×’×¨×¤×™×, ×‘×§×˜×¡×˜ ×•××“×“×™ ×¡×™×›×•×Ÿ.",
    advancedOpenSubtitle: "××¦×‘ ××ª×§×“× ×¤×ª×•×—. ×”×©×ª××©×• ×‘×”×’×“×¨×•×ª ×”×‘×§×˜×¡×˜ ×œ×”×ª×××•×ª.",
    advancedShortcut: "× ×™×ª×•×— ××ª×§×“×",
    advancedShortcutHint: "×¤×ª×— ×•×’×œ×•×œ ×œ× ×™×ª×•×— ×”××ª×§×“×",
    showAdvanced: "×¤×ª×— × ×™×ª×•×— ××ª×§×“×",
    hideAdvanced: "×¡×’×•×¨ × ×™×ª×•×— ××ª×§×“×",
    advancedAnalysisTitle: "× ×™×ª×•×— ××ª×§×“×",
    advancedAnalysisSubtitle: "××—×–×•×¨×™ ××—×™×¨, ×¤×™×¨×•×§, ×¨×•×•×—×™×•×ª ××•×œ ×‘× ×¦'××¨×§, ×”×§×©×¨ ××™×¨×•×¢×™ ×•×‘×™×Ÿ-×©×•×§×™.",
    confidenceLabel: "×¨××ª ×‘×™×˜×—×•×Ÿ",
    scoreTotalLabel: "×¦×™×•×Ÿ ×›×•×œ×œ",
    scorePriceLabel: "×¦×™×•×Ÿ ××—×™×¨",
    scoreCOTLabel: "×¦×™×•×Ÿ COT",
    latestCloseLabel: "××—×™×¨ ×¡×’×™×¨×” ××—×¨×•×Ÿ",
    maLabel: "×××•×¦×¢×™× 20/50/200",
    momLabel: "××•×× ×˜×•× 1M",
    cotLabel: "COT (Silver)",
    edgarLabel: "EDGAR",
    cotUnavailable: "COT ×œ× ×–××™×Ÿ (×‘×™× ×ª×™×™×).",
    edgarNoFiling: "×œ× × ××¦××” ×”×’×©×” ××—×¨×•× ×”.",
    edgarUnavailable: "EDGAR ×œ× ×–××™×Ÿ (×‘×™× ×ª×™×™×).",
    hitRateLabel: "×©×™×¢×•×¨ ×¤×’×™×¢×”",
    avgReturn5dLabel: "×ª×©×•××” ×××•×¦×¢×ª 5 ×™××™×",
    avgReturn10dLabel: "×ª×©×•××” ×××•×¦×¢×ª 10 ×™××™×",
    maxDrawdownLabel: "× ×¡×™×’×” ××§×¡×™××œ×™×ª",
    rsiToggle: "RSI",
    stdToggle: "StdDev",
    macdToggle: "MACD",
    bollToggle: "×‘×•×œ×™× ×’×¨",
    obvToggle: "OBV",
    maLongToggle: "MA1000",
    decompToggle: "Decomposition",
    langToggleEnglish: "×× ×’×œ×™×ª",
    langToggleHebrew: "×¢×‘×¨×™×ª",
    langToggleSpanish: "×¡×¤×¨×“×™×ª",
    switchToEnglishAria: "×”×—×œ×£ ×œ×× ×’×œ×™×ª",
    switchToHebrewAria: "×”×—×œ×£ ×œ×¢×‘×¨×™×ª",
    switchToSpanishAria: "×”×—×œ×£ ×œ×¡×¤×¨×“×™×ª",
    languageSelectorAria: "×‘×—×™×¨×ª ×©×¤×”",
    anomalyNowTitle: "×”×ª×¨××•×ª ×—×¨×™×’×•×ª (×©×›×‘×” 1)",
    anomalyScoreLabel: "××“×“ ×—×¨×™×’×•×ª",
    adxLabel: "ADX",
    atrLabel: "ATR (14)",
    alertCountLabel: "××¡×¤×¨ ×”×ª×¨××•×ª",
    alertListTitle: "××” ×—×¨×™×’ ×”×™×•×",
    cyclesToggle: "××—×–×•×¨×™ ××—×™×¨",
    noAlerts: "××™×Ÿ ×—×¨×™×’×•×ª ×—×–×§×•×ª ×”×™×•×.",
    backtestSettings: "×”×’×“×¨×•×ª ×‘×§×˜×¡×˜",
    openSettings: "×¤×ª×—",
    settingsHint: "×©×œ×™×˜×” ××”×™×¨×” ×œ×˜×•×•×—×™ ×‘×“×™×§×”, ×¢×œ×•×™×•×ª ×•××¡×˜×¨×˜×’×™×”.",
    backtestSettingsSubtitle: "×”×ª×××ª ×¤×¨××˜×¨×™ ×”×¡×™××•×œ×¦×™×” (×œ× ×™×™×¢×•×¥).",
    simulationDisclaimer: "×¡×™××•×œ×¦×™×” ×‘×œ×‘×“ Â· × ×ª×•× ×™× ×”×™×¡×˜×•×¨×™×™× Â· ××™×Ÿ ×™×™×¢×•×¥ ×¤×™× × ×¡×™",
    dateRangeLabel: "×˜×•×•×— ×ª××¨×™×›×™×",
    rangeAll: "×›×œ ×”×ª×§×•×¤×”",
    range1Y: "×©× ×” ××—×¨×•× ×”",
    range3Y: "×©×œ×•×© ×©× ×™× ××—×¨×•× ×•×ª",
    range5Y: "×—××© ×©× ×™× ××—×¨×•× ×•×ª",
    rangeCustom: "×˜×•×•×— ××•×ª××",
    maWindow: "×—×œ×•×Ÿ MA (××¡× ×Ÿ ××’××”)",
    rsiPeriod: "×ª×§×•×¤×ª RSI",
    rsiOversold: "RSI ××›×™×¨×•×ª ×™×ª×¨",
    rsiOverbought: "RSI ×§× ×™×•×ª ×™×ª×¨",
    bandWindow: "×—×œ×•×Ÿ ×‘×•×œ×™× ×’×¨",
    bandStd: "×¡×˜×™×™×ª ×ª×§×Ÿ",
    strategyCycleBasic: "×‘×¡×™×¡ ××—×–×•×¨×™",
    strategyRiskManaged: "× ×™×”×•×œ ×¡×™×›×•× ×™×",
    strategyBuyHold: "×§× ×™×™×” ×•×”×—×–×§×”",
    strategyNote: "×”×‘×§×˜×¡×˜ ××©×ª××© ×¨×§ ×‘×¡×™×’× ×œ×™× ×××•×©×¨×™× (×œ×œ× lookahead).",
    startDate: "×ª××¨×™×š ×”×ª×—×œ×”",
    endDate: "×ª××¨×™×š ×¡×™×•×",
    costsLabel: "×¢×œ×•×™×•×ª (bps)",
    slippageLabel: "×”×—×œ×§×” (× ×§×•×“×•×ª ×‘×¡×™×¡)",
    costsSelectedLabel: "×¢×œ×•×ª × ×‘×—×¨×ª (bps ×œ×¢×¡×§×”)",
    costDragLabel: "×©×—×™×§×” ××•×œ ×ª×©×•××ª ×‘×¨×•×˜×•",
    grossNetImpactLabel: "×ª×©×•××”: ×‘×¨×•×˜×• â†’ × ×˜×•",
    riskControlsLabel: "× ×™×”×•×œ ×¡×™×›×•× ×™×",
    useAtrSizing: "×©×™××•×© ×‘×§×‘×™×¢×ª ×’×•×“×œ ×œ×¤×™ ATR",
    targetDailyVol: "×™×¢×“ ×¡×˜×™×™×ª ×ª×§×Ÿ ×™×•××™×ª (%)",
    useStopLoss: "×©×™××•×© ×‘×¡×˜×•×¤-×œ×•×¡",
    stopAtrMult: "××§×“× ATR ×œ×¡×˜×•×¤",
    useTrailingStop: "×”×¤×¢×œ×ª ×˜×¨×™×™×œ×™× ×’ ×¡×˜×•×¤",
    trailingAtrMult: "××§×“× ATR ×œ×˜×¨×™×™×œ×™× ×’",
    useVarSizing: "×’×•×“×œ ×¤×•×–×™×¦×™×” ×œ×¤×™ VaR",
    varConfidence: "×¨××ª ×‘×™×˜×—×•×Ÿ VaR (%)",
    varRisk: "×¡×™×›×•×Ÿ ×¤×•×–×™×¦×™×” (%)",
    varLookback: "×—×œ×•×Ÿ VaR (×™××™×)",
    runSimulation: "×”×¨×¥ ×¡×™××•×œ×¦×™×”",
    strategyPick: "×‘×—×™×¨×ª ××¡×˜×¨×˜×’×™×”",
    strategyTrend: "××’××”",
    strategyRange: "×“×©×“×•×©",
    strategyHybrid: "×”×™×‘×¨×™×“×™",
    grossNet: "×‘×¨×•×˜×• / × ×˜×•",
    grossLabel: "×‘×¨×•×˜×•",
    netLabel: "× ×˜×•",
    maToggle: "×××•×¦×¢×™×",
    signalsToggle: "×§× ×™×™×”/××›×™×¨×”",
    equityViewLabel: "×ª×¦×•×’×ª ×¨×•×•×—×™×•×ª",
    riskTitle: "××“×“×™ ×¡×™×›×•×Ÿ",
    ulcerLabel: "××“×“ ××•×œ×¦×¨",
    worstMonthLabel: "×”×—×•×“×© ×”×’×¨×•×¢ ×‘×™×•×ª×¨",
    tradeLogTitle: "×™×•××Ÿ ×¢×¡×§××•×ª",
    tradeEntry: "×›× ×™×¡×”",
    tradeExit: "×™×¦×™××”",
    tradeReason: "×˜×¨×™×’×¨",
    tradeReturn: "×¨×•×•×— %",
    tradeHold: "×–××Ÿ ×”×—×–×§×”"
  },
  en: {
    title: "SLV Monitor",
    subtitle: "Static dashboard on GitHub Pages + a 'brain' running in GitHub Actions updating JSON.",
    howItWorksLabel: "How it works",
    howItWorksTooltip: "Open the explainer for the dashboard and Probability Engine",
    alert: "System recommendations are the result of statistical processing and do not constitute advice or a call for immediate action. Combine signals with other factors like macro news, monetary policy, and personal considerations.",
    priceTitle: "Price",
    rangeLabel: "Range:",
    cycleTitle: "Recent Peaks/Troughs Cycles",
    cycleEndDate: "End Date",
    cycleStartDate: "Start Date",
    cycleDirection: "Direction",
    cycleLength: "Length",
    cycleAmplitude: "Amplitude",
    performanceScoreTitle: "Performance Scorecard",
    perfSummaryUpdatedLabel: "Updated",
    equityTitle: "Equity vs Benchmark (SLV)",
    performanceTitle: "Performance",
    feesImpactTitle: "Fees impact",
    feesSensitivityLabel: "Fees sensitivity",
    roundTripLabel: "Round-trip (bps)",
    tradesLabel: "Trades",
    feesTotalLabel: "Total fees",
    feeDragLabel: "Fee drag vs gross return",
    noTradesFees: "No trades â†’ fees impact = 0",
    algoScoreLabel: "Algorithm Score",
    sharpeLabel: "Sharpe Ratio",
    cycleCaptureLabel: "Cycle Capture",
    rsiLabel: "RSI (14)",
    stdLabel: "Rolling StdDev (20)",
    macdLabel: "MACD (12/26/9)",
    bollLabel: "Bollinger Bands (20, 2Ïƒ)",
    obvLabel: "OBV",
    maLongLabel: "MA1000",
    perfUpdatedLabel: "Perf Updated",
    decompTitle: "Decomposition",
    decompUpdatedLabel: "Updated",
    decompPeriodLabel: "Period",
    decompInputLabel: "Input",
    decompParamsLabel: "Parameters",
    trendTitle: "Trend",
    seasonalTitle: "Seasonal",
    residualTitle: "Residual",
    noCycles: "No cycles detected yet.",
    perfSeriesUnavailable: "Performance series unavailable.",
    benchUnavailable: "Benchmark window unavailable.",
    decompUnavailable: "Decomposition unavailable.",
    decompMissing: "Decomposition unavailable (missing files).",
    seriesLabel: "Series",
    totalReturnLabel: "Total Return",
    sortinoLabel: "Sortino",
    strategyLabel: "Strategy",
    buyHoldLabel: "Buy & Hold",
    updatedPrefix: "Updated (UTC)",
    metaSourceLabel: "Data source",
    metaCoverageLabel: "Coverage",
    metaUpdatedLabel: "Last updated",
    metaSnapshotStatusLabel: "Snapshot status",
    metaSnapshotAgeLabel: "Snapshot age",
    snapshotStatusLive: "Live",
    snapshotStatusCached: "Cached",
    snapshotStatusUnknown: "Unknown",
    snapshotErrorPrefix: "Data refresh error",
    marketSnapshotTitle: "Market Snapshot",
    occurrencesLabel: "Occurrences",
    historicalRangeLabel: "Common range (5d)",
    whatItMeansTitle: "What this usually means",
    analogiesTitle: "Analogies",
    analogiesNote: "Historical peers Â· No instructions",
    probEngineTitle: "Probability Engine",
    probEngineInfoTooltip: "Open explainer for the Probability Engine",
    probEngineInfoLabel: "ğŸ” Info",
    probEngineSettingsLabel: "Settings",
    probEngineProbLabel: "P(up)",
    probEngineMedianLabel: "Median",
    probEngineNeighborsLabel: "Neighbors",
    probEngineRangeLabel: "Range",
    probEngineConfidenceLow: "Low confidence",
    probEngineConfidenceMedium: "Medium confidence",
    probEngineConfidenceHigh: "High confidence",
    probEngineHorizonLabel: "Forecast horizon (days)",
    probEngineKLabel: "K (neighbors)",
    probEngineWeightingLabel: "Weighting method",
    probEngineSuccessThresholdLabel: "Success threshold (return >)",
    probEngineHighlightLabel: "Highlight if P(up) above (%)",
    probEngineApplyLabel: "Apply",
    probEngineHighlightHit: "P(up) cleared the highlight bar",
    eventContextTitle: "Event Context",
    eventContextLabel: "Event Context",
    eventContextNone: "No known event window",
      contextTitle: "Cross-Market Context",
      contextNote: "Dollar / gold / rates framing; historical only.",
      contextFooter: "Context only; not a trading instruction.",
      contextHistLabel: "Historical (5d)",
      contextHistFallback: "Insufficient history for this bucket",
      contextDisclaimer: "Historical context only; not a promise.",
      contextLowSample: "Low sample size; weak context.",
      contextValueLabel: "Value",
      contextDateLabel: "Last date",
      contextZLabel: "Z-score",
      contextPctLabel: "Percentile",
      contextChangeLabel: "Change vs start",
      contextSourceLabel: "Sources",
      contextPUp5d: "P(up 5d)",
      contextMedian5d: "Median 5d",
      contextPUp10d: "P(up 10d)",
      contextMedian10d: "Median 10d",
    localTimeLabel: "Local time",
    freshLabel: "Fresh",
    staleLabel: "Stale",
    recentLabel: "Recent",
    missingData: "Missing",
    eventPhasePre: "Pre-event",
    eventPhaseToday: "Event day",
    eventPhasePost: "Post-event",
    eventPhaseUpcoming: "Scheduled",
    eventNameLabel: "Event",
    volImpactLabel: "Volatility context",
    directionalNoteLabel: "Directional note",
    eventProb1dLabel: "Event-day outcomes",
    eventProb5dLabel: "5-day outcomes",
    sampleSizeLabel: "Sample size",
    medianShortLabel: "Median",
    eventContextFooter: "Context only; not a trigger or forecast.",
    eventTimingLabel: "Distance to event",
    deviationPanelTitle: "Deviation vs history",
    zNowLabel: "Z-score now",
    pctNowLabel: "Percentile now",
    bandLabel: "Band",
    heatmapTitle: "Heatmap timeline",
    heatmapNote: "Color = context only. Hover to see numbers.",
    heatmapLegendTitle: "Color key",
    heatmapMeaningExtremeLowDeviation: "Far below baseline (deep negative deviation).",
    heatmapMeaningLowDeviation: "Below baseline (negative deviation).",
    heatmapMeaningNeutralDeviation: "Near baseline (low deviation).",
    heatmapMeaningHighDeviation: "Above baseline (positive deviation).",
    heatmapMeaningExtremeHighDeviation: "Well above baseline (sharp positive deviation).",
    heatmapMeaningLowVol: "Low ATR% Â· Calmer-than-usual daily moves.",
    heatmapMeaningNormalVol: "Normal ATR% Â· Typical volatility.",
    heatmapMeaningHighVol: "High ATR% Â· Elevated volatility.",
    heatmapMeaningBearishMom: "Bearish ROC20 Â· Downside momentum.",
    heatmapMeaningNeutralMom: "Neutral ROC20 Â· Flat momentum.",
    heatmapMeaningBullishMom: "Bullish ROC20 Â· Upside momentum.",
    heatmapTooltipDate: "Date",
    heatmapTooltipClose: "Close",
    heatmapTooltipZScore: "Z-score",
    heatmapTooltipPercentile: "Percentile",
    heatmapTooltipAtrPct: "ATR%",
    heatmapTooltipRoc20: "ROC20",
    heatmapTooltipMeaning: "Meaning",
    heatmapMissingData: "No data for this period.",
    viewLabel: "View",
    weeklyAgg: "Weekly",
    limitsCopy: "Historical only; not a promise.",
    medianLabel: "Median 5d",
    advancedTitle: "Advanced",
    advancedClosedTitle: "Advanced Analysis",
    advancedOpenTitle: "Advanced is open",
    advancedClosedSubtitle: "Open advanced charts, backtest, risk metrics, and diagnostics.",
    advancedOpenSubtitle: "Advanced is open. Use Backtest Settings to customize the simulation.",
    advancedShortcut: "Advanced Analysis",
    advancedShortcutHint: "Open and scroll to Advanced Analysis",
    showAdvanced: "Show Advanced Analysis",
    hideAdvanced: "Hide Advanced Analysis",
    advancedAnalysisTitle: "Advanced Analysis",
    advancedAnalysisSubtitle: "Cycles, decomposition, equity vs benchmark, event context, cross-market context.",
    confidenceLabel: "Confidence",
    scoreTotalLabel: "Score Total",
    scorePriceLabel: "Price Score",
    scoreCOTLabel: "COT Score",
    latestCloseLabel: "Latest Close",
    maLabel: "MA20/50/200",
    momLabel: "1M Mom%",
    cotLabel: "COT (Silver)",
    edgarLabel: "EDGAR",
    cotUnavailable: "COT unavailable (yet).",
    edgarNoFiling: "No latest filing found.",
    edgarUnavailable: "EDGAR unavailable (yet).",
    hitRateLabel: "Hit Rate",
    avgReturn5dLabel: "Avg Return 5d",
    avgReturn10dLabel: "Avg Return 10d",
    maxDrawdownLabel: "Max Drawdown",
    rsiToggle: "RSI",
    stdToggle: "StdDev",
    macdToggle: "MACD",
    bollToggle: "Bollinger",
    obvToggle: "OBV",
    maLongToggle: "MA1000",
    decompToggle: "Decomposition",
    langToggleEnglish: "English",
    langToggleHebrew: "×¢×‘×¨×™×ª",
    langToggleSpanish: "Spanish",
    switchToEnglishAria: "Switch to English",
    switchToHebrewAria: "Switch to Hebrew",
    switchToSpanishAria: "Switch to Spanish",
    languageSelectorAria: "Language selector",
    anomalyNowTitle: "Layer 1 Â· Alerts",
    anomalyScoreLabel: "Anomaly score",
    adxLabel: "ADX",
    atrLabel: "ATR (14)",
    alertCountLabel: "Alerts",
    alertListTitle: "What is unusual",
    cyclesToggle: "Cycles",
    noAlerts: "No strong anomalies today.",
    backtestSettings: "Backtest settings",
    openSettings: "Open",
    settingsHint: "Quick control over test window, costs and regime.",
    backtestSettingsSubtitle: "Adjust the backtest simulation parameters (not advice).",
    simulationDisclaimer: "Simulation only Â· Historical data Â· Not financial advice",
    dateRangeLabel: "Date range",
    rangeAll: "All",
    range1Y: "Last 1Y",
    range3Y: "Last 3Y",
    range5Y: "Last 5Y",
    rangeCustom: "Custom",
    maWindow: "MA window (trend filter)",
    rsiPeriod: "RSI period",
    rsiOversold: "RSI oversold",
    rsiOverbought: "RSI overbought",
    bandWindow: "Bollinger window",
    bandStd: "Band Ïƒ (std dev)",
    strategyCycleBasic: "cycle_basic",
    strategyRiskManaged: "risk_managed",
    strategyBuyHold: "buy_hold",
    strategyNote: "Backtest uses confirmed signals only (no lookahead).",
    startDate: "Start date",
    endDate: "End date",
    costsLabel: "Costs (bps)",
    slippageLabel: "Slippage (bps)",
    costsSelectedLabel: "Selected costs (bps per trade)",
    costDragLabel: "Cost drag vs gross return",
    grossNetImpactLabel: "Gross â†’ Net return",
    riskControlsLabel: "Risk controls",
    useAtrSizing: "Use ATR sizing",
    targetDailyVol: "Target daily vol (%)",
    useStopLoss: "Use stop-loss",
    stopAtrMult: "Stop ATR multiple",
    useTrailingStop: "Enable trailing stop",
    trailingAtrMult: "Trailing ATR multiple",
    useVarSizing: "Size by VaR",
    varConfidence: "VaR confidence (%)",
    varRisk: "Risk budget per trade (%)",
    varLookback: "VaR lookback (days)",
    runSimulation: "Run Simulation",
    strategyPick: "Strategy",
    strategyTrend: "Trend",
    strategyRange: "Range",
    strategyHybrid: "Hybrid",
    grossNet: "Gross / Net",
    grossLabel: "Gross",
    netLabel: "Net",
    maToggle: "MAs",
    signalsToggle: "Buy/Sell",
    equityViewLabel: "Equity view",
    riskTitle: "Risk metrics",
    ulcerLabel: "Ulcer Index",
    worstMonthLabel: "Worst month",
    tradeLogTitle: "Trade log",
    tradeEntry: "Entry",
    tradeExit: "Exit",
    tradeReason: "Trigger",
    tradeReturn: "Return%",
    tradeHold: "Hold"
  }
};

const translationOverrides = {
  es: {
    langToggleEnglish: "InglÃ©s",
    langToggleHebrew: "Hebreo",
    langToggleSpanish: "EspaÃ±ol",
    switchToEnglishAria: "Cambiar a inglÃ©s",
    switchToHebrewAria: "Cambiar a hebreo",
    switchToSpanishAria: "Cambiar a espaÃ±ol",
    languageSelectorAria: "Seleccionar idioma",
    howItWorksLabel: "CÃ³mo funciona",
    howItWorksTooltip: "Abrir la explicaciÃ³n del panel y del Motor de Probabilidad",
    probEngineInfoTooltip: "Abrir la explicaciÃ³n del Motor de Probabilidad",
    advancedShortcut: "AnÃ¡lisis avanzado",
    advancedShortcutHint: "Abrir y desplazarse al AnÃ¡lisis avanzado",
  },
};

const supportedLanguages = ["en", "he", "es"];

const translations = buildTranslationTable(baseLanguageStrings, translationOverrides, supportedLanguages);

function buildTranslationTable(base, overrides, languages) {
  const table = {};
  const languageList = languages || Array.from(new Set([...Object.keys(base || {}), ...Object.keys(overrides || {})]));
  const sources = { ...base, ...overrides };

  languageList.forEach((lang) => {
    const dict = sources[lang] || {};
    Object.entries(dict).forEach(([key, value]) => {
      if (!table[key]) table[key] = {};
      table[key][lang] = value;
    });
  });

  Object.values(table).forEach((entry) => {
    languageList.forEach((lang) => {
      if (!entry[lang] && entry.en) entry[lang] = entry.en;
    });
  });

  return table;
}

function fmt(x, d = 2) {
  if (x === null || x === undefined || Number.isNaN(x)) return "â€”";
  return Number(x).toFixed(d);
}

function fmtPct(x, d = 1) {
  if (x === null || x === undefined || Number.isNaN(x)) return "â€”";
  return `${(Number(x) * 100).toFixed(d)}%`;
}

function movingAverage(arr, period) {
  const res = [];
  for (let i = 0; i < arr.length; i++) {
    if (i + 1 < period) { res.push(null); continue; }
    const slice = arr.slice(i + 1 - period, i + 1);
    const avg = slice.reduce((a, b) => a + b, 0) / period;
    res.push(avg);
  }
  return res;
}

function bollinger(arr, period = 20, mult = 2) {
  const ma = movingAverage(arr, period);
  const upper = [];
  const lower = [];
  for (let i = 0; i < arr.length; i++) {
    if (i + 1 < period) { upper.push(null); lower.push(null); continue; }
    const slice = arr.slice(i + 1 - period, i + 1);
    const mean = ma[i];
    const variance = slice.reduce((acc, v) => acc + (v - mean) ** 2, 0) / period;
    const std = Math.sqrt(variance);
    upper.push(mean + mult * std);
    lower.push(mean - mult * std);
  }
  return { ma, upper, lower };
}

function computeRsi(arr, period = 14) {
  const gains = [];
  const losses = [];
  for (let i = 1; i < arr.length; i++) {
    const change = arr[i] - arr[i - 1];
    gains.push(Math.max(change, 0));
    losses.push(Math.max(-change, 0));
  }
  const rsi = [null];
  for (let i = 1; i < arr.length; i++) {
    if (i < period) { rsi.push(null); continue; }
    const gainSlice = gains.slice(i - period, i);
    const lossSlice = losses.slice(i - period, i);
    const avgGain = gainSlice.reduce((a, b) => a + b, 0) / period;
    const avgLoss = lossSlice.reduce((a, b) => a + b, 0) / period;
    const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
    const value = 100 - 100 / (1 + rs);
    rsi.push(value);
  }
  return rsi;
}

function normalizeEquityFromPrices(prices) {
  const eq = [{ index: 0, equity: 1 }];
  for (let i = 1; i < prices.length; i++) {
    const prev = prices[i - 1];
    const curr = prices[i];
    const ret = (curr - prev) / prev;
    const last = eq[eq.length - 1].equity;
    eq.push({ index: i, equity: last * (1 + ret) });
  }
  return eq.slice(1);
}

function applyCosts(equitySeries, costBps = 0.0) {
  const cost = costBps / 10000;
  if (!cost) return equitySeries;
  const out = [];
  for (let i = 0; i < equitySeries.length; i++) {
    if (i === 0) { out.push({ ...equitySeries[i] }); continue; }
    const prev = equitySeries[i - 1].equity;
    const curr = equitySeries[i].equity;
    const grossRet = curr / prev - 1;
    const netRet = grossRet - cost;
    out.push({ index: equitySeries[i].index, equity: out[i - 1].equity * (1 + netRet) });
  }
  return out;
}

function formatSnapshotAge(isoString) {
  if (!isoString) return "â€”";
  const parsed = new Date(isoString);
  if (Number.isNaN(parsed.getTime())) return "â€”";
  const diffMs = Date.now() - parsed.getTime();
  if (diffMs < 0) return "â€”";
  const minutes = Math.floor(diffMs / 60000);
  if (minutes < 60) return `${minutes}m`;
  const hours = Math.floor(minutes / 60);
  if (hours < 48) return `${hours}h`;
  const days = Math.floor(hours / 24);
  if (days < 45) return `${days}d`;
  const months = Math.floor(days / 30);
  return `${months}mo`;
}

let meta = {};
let prices = { dates: [], close: [] };
let priceDates = [];
let probabilistic = null;
let actionSignal = null;
let anomalies = {};
let perfSummary = {};
let equityCurve = {};
let cycleStats = {};
let heatmaps = { deviation: null, volatility: null, momentum: null, stats: null };
let eventContext = { nearest: null };
let eventImpactStats = {};
let currentContext = null;
let crossMarketContext = null;
let conditionalContextStats = null;
let buyHoldCurve = [];
let featureRows = [];
let probabilityDaily = [];
let simpleRulesResult = null;
let backtestEquity = null;
let backtestFeesImpact = null;
let backtestFeesSensitivity = null;
let backtestTradeLog = null;
let backtestRiskMetrics = null;
let perfAtr = null;
let perfAdx = null;
let decomposition = { status: "missing", meta: null, trend: [], seasonal: [], residual: [], dates: [], error: "missing" };

const ADVANCED_STORAGE_KEY = "advanced_open";

function readAdvancedPreference() {
  try {
    const stored = localStorage.getItem(ADVANCED_STORAGE_KEY);
    if (stored === null) return true;
    return stored === "true";
  } catch (err) {
    console.warn("Could not read advanced panel preference", err);
    return true;
  }
}

let state = {
  range: "3m",
  lang: detectLang(),
  showMa: true,
  showBoll: true,
  showCycles: true,
  showNet: true,
  showSensitivity: false,
  costBps: 10,
  slippageBps: 5,
  startDate: "",
  endDate: "",
  dateRangePreset: "all",
  maWindow: 50,
  rsiPeriod: 14,
  rsiOversold: 35,
  rsiOverbought: 65,
  bandWindow: 20,
  bandStd: 2,
  strategy: "cycle_basic",
  useAtrSizing: false,
  targetDailyVol: 1.0,
  useStopLoss: false,
  stopAtrMult: 2.5,
  useTrailingStop: false,
  trailingAtrMult: 3.0,
  useVarSizing: false,
  varConfidence: 95,
  varRisk: 1.0,
  varLookback: 60,
  useCustomBacktest: false,
  heatmapMode: "deviation",
  heatmapRange: "all",
  heatmapWeekly: false,
  isAdvancedOpen: readAdvancedPreference(),
  probabilityEngine: {
    horizon: 20,
    k: 150,
    threshold: 0,
    weighting: "inverse_distance",
    highlightThreshold: 0.65,
  },
  probabilityResult: null,
};

function t(key, lang = state.lang) {
  const entry = translations[key];
  if (!entry) return key;
  return entry[lang] ?? entry.en ?? Object.values(entry)[0] ?? key;
}

function localizeCopy(text, fallbackKey) {
  if (!text) return fallbackKey ? t(fallbackKey) : "";
  const normalized = text.trim();
  const dictionary = {
    "Context only; not a trading instruction.": "contextFooter",
    "Context only; not a trade idea.": "contextFooter",
    "Historical context only; not a promise.": "contextDisclaimer",
    "Dollar / gold / rates framing; historical only.": "contextNote",
    "Historical peers Â· No instructions": "analogiesNote",
  };
  const key = dictionary[normalized];
  return key ? t(key) : text;
}

function updateAdvancedCopy() {
  const heading = document.getElementById("advancedHeading");
  const subtitle = document.getElementById("advancedSubtitle");
  const toggle = document.getElementById("advancedToggle");
  const panel = document.getElementById("advancedPanel");
  if (!heading || !subtitle || !toggle || !panel) return;
  heading.textContent = state.isAdvancedOpen ? t("advancedOpenTitle") : t("advancedClosedTitle");
  subtitle.textContent = state.isAdvancedOpen ? t("advancedOpenSubtitle") : t("advancedClosedSubtitle");
  toggle.textContent = state.isAdvancedOpen ? t("hideAdvanced") : t("showAdvanced");
  toggle.setAttribute("aria-expanded", state.isAdvancedOpen ? "true" : "false");
  panel.style.display = state.isAdvancedOpen ? "block" : "none";
  try {
    localStorage.setItem(ADVANCED_STORAGE_KEY, state.isAdvancedOpen ? "true" : "false");
  } catch (err) {
    console.warn("Could not persist advanced panel preference", err);
  }
}

function openAdvancedSection(shouldScroll = true) {
  if (!state.isAdvancedOpen) {
    state.isAdvancedOpen = true;
    updateAdvancedCopy();
  } else {
    updateAdvancedCopy();
  }

  const target =
    document.getElementById("advancedShell") ||
    document.getElementById("advancedAnalysisCard") ||
    document.getElementById("advancedPanel");
  if (shouldScroll && target) {
    target.scrollIntoView({ behavior: "smooth", block: "start" });
  }
}

function attachAdvancedToggle() {
  const advancedToggle = document.getElementById("advancedToggle");
  if (!advancedToggle || advancedToggle.dataset.bound === "true") return;
  advancedToggle.dataset.bound = "true";
  advancedToggle.addEventListener("click", () => {
    state.isAdvancedOpen = !state.isAdvancedOpen;
    updateAdvancedCopy();
  });
}

attachAdvancedToggle();
updateAdvancedCopy();
attachTooltips(document, state.lang);

let latestHubState = null;
hub.subscribe((state) => {
  latestHubState = state;
  dataErrors = state.errors || {};
  renderDataStatusPanel(state);

  if (state.status === "loading") {
    setGlobalStatus(`<b>Loading dataâ€¦</b> ${state.progress.done}/${state.progress.total}`);
  }

  if (state.status === "ready" && Object.keys(state.errors || {}).length === 0) {
    setGlobalStatus("");
  }

  if (state.status === "error") {
    const err = state.errors?.meta;
    setGlobalStatus(`<b>Data load failed (meta.json)</b><br/>${err?.message || "Unknown error"}`, "error");
    if (err?.details) console.table(err.details);
  }
});

(async () => {
  try {
    setGlobalStatus("<b>Loading dataâ€¦</b>");
    const loadResult = await hub.loadAll();
    if (!loadResult.ok) {
      console.warn("Partial data load. Failed keys:", loadResult.failedKeys);
    }

    meta = hub.getMeta() || {};
    const datasets = {
      legacyPrices: hub.getDataset("legacyPrices"),
      prices: hub.getDataset("prices"),
      probabilistic: hub.getDataset("probabilistic"),
      signalLatest: hub.getDataset("signalLatest"),
      anomalies: hub.getDataset("anomalies"),
      perfSummary: hub.getDataset("perfSummary"),
      equityCurve: hub.getDataset("equityCurve"),
      cycleStats: hub.getDataset("cycleStats"),
      heatmapDeviation: hub.getDataset("heatmapDeviation"),
      heatmapVolatility: hub.getDataset("heatmapVolatility"),
      heatmapMomentum: hub.getDataset("heatmapMomentum"),
      statsByBand: hub.getDataset("statsByBand"),
      eventContext: hub.getDataset("eventContext"),
      eventImpactStats: hub.getDataset("eventImpactStats"),
      crossMarketCurrent: hub.getDataset("crossMarketCurrent"),
      crossMarketConditional: hub.getDataset("crossMarketConditional"),
      crossMarketContext: hub.getDataset("crossMarketContext"),
      probabilityDaily: hub.getDataset("probabilityDaily"),
      cotLatest: hub.getDataset("cotLatest"),
      cotHistory: hub.getDataset("cotHistory"),
      backtestEquity: hub.getDataset("backtestEquity"),
      backtestFeesImpact: hub.getDataset("backtestFeesImpact"),
      backtestFeesSensitivity: hub.getDataset("backtestFeesSensitivity"),
      backtestTradeLog: hub.getDataset("backtestTradeLog"),
      backtestRiskMetrics: hub.getDataset("backtestRiskMetrics"),
      perfAtr: hub.getDataset("perfAtr"),
      perfAdx: hub.getDataset("perfAdx"),
      decompositionMeta: hub.getDataset("decompositionMeta"),
      decompositionTrend: hub.getDataset("decompositionTrend"),
      decompositionSeasonal: hub.getDataset("decompositionSeasonal"),
      decompositionResidual: hub.getDataset("decompositionResidual"),
    };

    const metaSourceUrl = latestHubState?.loadedFrom?.metaUrl;
    if (metaSourceUrl) {
      setGlobalStatus(`<b>Data loaded</b><br/>${metaSourceUrl}`, "success");
      const metaSourceEl = document.getElementById("metaSource");
      if (metaSourceEl) metaSourceEl.title = `Loaded from: ${metaSourceUrl}`;
    } else {
      setGlobalStatus("<b>Data loaded</b>", "success");
    }

    decomposition = buildDecompositionFromDatasets(datasets);

    eventContext = datasets.eventContext || { nearest: null };
    eventImpactStats = datasets.eventImpactStats || {};
    currentContext = datasets.crossMarketCurrent;
    crossMarketContext = datasets.crossMarketContext;
    conditionalContextStats = datasets.crossMarketConditional;
    perfAtr = datasets.perfAtr;
    perfAdx = datasets.perfAdx;

    prices = normalizePricesDataset(datasets.prices, datasets.legacyPrices);
    const priceDateStrings = Array.isArray(prices?.dates) ? prices.dates.filter(Boolean) : [];
    priceDates = priceDateStrings.map((d) => new Date(d));
    state.startDate = priceDateStrings[0] ?? state.startDate;
    state.endDate = priceDateStrings[priceDateStrings.length - 1] ?? state.endDate;
    buyHoldCurve = normalizeEquityFromPrices(prices.close || []);
    featureRows = buildFeatureRows(priceDateStrings, Array.isArray(prices?.close) ? prices.close : []);
    state.probabilityResult = featureRows.length ? knnAnalogProbability(featureRows, state.probabilityEngine) : null;
    probabilityDaily = injectCotIntoDaily(datasets.probabilityDaily || [], datasets.cotHistory);
    renderCotCard(datasets.cotLatest, datasets.cotHistory, dataErrors.cotLatest || dataErrors.cotHistory, state.lang);
    renderTradingSimulationCard(probabilityDaily);
    simpleRulesResult = backtestRuleset(probabilityDaily);
    renderRulesRecommendation(simpleRulesResult, dataErrors.probabilityDaily, state.lang);
    renderRulesExplain(simpleRulesResult, state.lang);
    renderRulesBacktest(probabilityDaily, simpleRulesResult, state.lang);
    heatmaps = {
      deviation: datasets.heatmapDeviation,
      volatility: datasets.heatmapVolatility,
      momentum: datasets.heatmapMomentum,
      stats: datasets.statsByBand,
    };
    actionSignal = datasets.signalLatest;
    probabilistic = datasets.probabilistic || {};
    anomalies = datasets.anomalies || {};
    perfSummary = datasets.perfSummary || {};
    equityCurve = datasets.equityCurve || {};
    cycleStats = datasets.cycleStats || {};
    backtestEquity = datasets.backtestEquity;
    backtestFeesImpact = datasets.backtestFeesImpact;
    backtestFeesSensitivity = datasets.backtestFeesSensitivity;
    backtestTradeLog = datasets.backtestTradeLog;
    backtestRiskMetrics = datasets.backtestRiskMetrics;
    if (backtestEquity?.fees) {
      state.costBps = backtestEquity.fees.cost_bps ?? state.costBps;
      state.slippageBps = backtestEquity.fees.slippage_bps ?? state.slippageBps;
    }
    let lastBacktest = { trades: backtestTradeLog?.trades || [] };
    const atrSeries = Array.isArray(perfAtr?.atr) ? perfAtr.atr : [];
    const adxSeries = Array.isArray(perfAdx?.adx) ? perfAdx.adx : [];

  function languageKey(lang) {
    if (lang === "he") return "langToggleHebrew";
    if (lang === "es") return "langToggleSpanish";
    return "langToggleEnglish";
  }

  function renderLanguageSelector() {
    const langSelect = document.getElementById("langSelect");
    if (!langSelect) return;

    langSelect.innerHTML = "";
    supportedLanguages.forEach((lang) => {
      const option = document.createElement("option");
      option.value = lang;
      option.textContent = t(languageKey(lang));
      langSelect.appendChild(option);
    });

    langSelect.value = state.lang;
    langSelect.setAttribute("aria-label", t("languageSelectorAria"));
  }

  function applyLanguage() {
    document.documentElement.lang = state.lang;
    document.body.dir = state.lang === "he" ? "rtl" : "ltr";
    document.querySelectorAll("[data-i18n]").forEach((el) => {
      const key = el.getAttribute("data-i18n");
      el.textContent = t(key);
    });
    const probInfoBtn = document.getElementById("probEngineInfoBtn");
    if (probInfoBtn) probInfoBtn.title = t("probEngineInfoTooltip");
    const howItWorksBtn = document.getElementById("howItWorksBtn");
    if (howItWorksBtn) howItWorksBtn.title = t("howItWorksTooltip");
    const advancedShortcut = document.getElementById("advancedShortcut");
    if (advancedShortcut) advancedShortcut.title = t("advancedShortcutHint");
    renderLanguageSelector();
  }

  function updateDateRangeUi() {
    const select = document.getElementById("dateRangeSelect");
    const custom = document.getElementById("customDateFields");
    if (select) select.value = state.dateRangePreset;
    if (custom) custom.style.display = state.dateRangePreset === "custom" ? "grid" : "none";
  }

  function syncPnlModeRadios() {
    document.querySelectorAll('input[name="equityMode"]').forEach((r) => {
      r.checked = state.showNet ? r.value === "net" : r.value === "gross";
    });
    document.querySelectorAll('input[name="pnlMode"]').forEach((r) => {
      r.checked = state.showNet ? r.value === "net" : r.value === "gross";
    });
  }

  function eventPhaseLabel(status) {
    if (status === "PRE_EVENT") return t("eventPhasePre");
    if (status === "EVENT_DAY") return t("eventPhaseToday");
    if (status === "POST_EVENT") return t("eventPhasePost");
    if (status === "UPCOMING") return t("eventPhaseUpcoming");
    return t("eventContextNone");
  }

  function eventTimingText(context) {
    const delta = context?.nearest?.days_to_event ?? context?.days_to_event;
    if (typeof delta !== "number") return "";
    if (delta === 0) return t("eventPhaseToday");
    const days = Math.abs(delta);
    return delta > 0 ? `${days}d ${t("eventTimingLabel")}` : `${days}d ${t("eventPhasePost")}`;
  }

  function renderEventContext(context, statsByType, error) {
    const badge = document.getElementById("eventContextBadge");
    const card = document.getElementById("eventContextCard");
    if (error) { renderCardError("eventContextCard", t("eventContextTitle"), error); return; }
    const nearest = context?.nearest;
    if (!context || !nearest) {
      badge.textContent = t("eventContextNone");
      card.style.display = "none";
      return;
    }

    const phaseText = eventPhaseLabel(nearest.phase);
    const timing = eventTimingText(context);
    const eventStats = statsByType?.[nearest.type] || {};
    const eventDay = eventStats.event_day || {};
    const post5d = eventStats.post_5d || {};
    const confidence = eventStats.confidence || context.expected_effects?.direction?.confidence;

    badge.textContent = `${t("eventContextLabel")}: ${nearest.type ?? "â€”"} â€¢ ${phaseText}${timing ? ` (${timing})` : ""}`;
    card.style.display = "block";
    document.getElementById("eventPhaseChip").textContent = phaseText;
    document.getElementById("eventPriorityChip").textContent = nearest.priority ? nearest.priority.toUpperCase() : "â€”";
    document.getElementById("eventName").textContent = nearest.title || nearest.type || "â€”";
    document.getElementById("eventTiming").textContent = timing || "â€”";

    const vol = context.expected_effects?.volatility;
    const dir = context.expected_effects?.direction;
    document.getElementById("eventVolLabel").textContent = vol?.label || "â€”";
    const volBits = [];
    if (typeof vol?.atr_change_median === "number") volBits.push(`ATR Î” median ${fmtPct(vol.atr_change_median, 1)}`);
    if (eventDay?.n) volBits.push(`n=${eventDay.n}`);
    if (vol?.confidence) volBits.push(`${t("confidenceLabel")}: ${vol.confidence}`);
    document.getElementById("eventVolStats").textContent = volBits.join(" Â· ") || "â€”";

    document.getElementById("eventDirection").textContent = dir?.label || "â€”";
    const dirBits = [];
    if (typeof dir?.p_up_1d === "number") dirBits.push(`P(up 1d) ${fmtPct(dir.p_up_1d, 0)}`);
    if (typeof dir?.p_up_5d === "number") dirBits.push(`P(up 5d) ${fmtPct(dir.p_up_5d, 0)}`);
    if (confidence) dirBits.push(`${t("confidenceLabel")}: ${confidence}`);
    document.getElementById("eventDirStats").textContent = dirBits.join(" Â· ") || "â€”";

    const prob1d = typeof eventDay.p_up_1d === "number" ? fmtPct(eventDay.p_up_1d, 0) : "â€”";
    const med1d = typeof eventDay.median_1d === "number" ? fmtPct(eventDay.median_1d, 2) : "â€”";
    document.getElementById("eventProb1d").textContent = prob1d;
    document.getElementById("eventMedian1d").textContent = `${t("medianShortLabel")}: ${med1d}`;

    const prob5d = typeof post5d.p_up_5d === "number" ? fmtPct(post5d.p_up_5d, 0) : "â€”";
    const med5d = typeof post5d.median_5d === "number" ? fmtPct(post5d.median_5d, 2) : "â€”";
    document.getElementById("eventProb5d").textContent = prob5d;
    document.getElementById("eventMedian5d").textContent = `${t("medianShortLabel")}: ${med5d}`;

    const framingNote = localizeCopy(context.framing?.note);
    const description = [context.framing?.headline, framingNote].filter(Boolean).join(" Â· ");
    document.getElementById("eventContextSummary").textContent = description || t("eventContextFooter");
    document.getElementById("eventContextFooter").textContent = `${t("eventContextFooter")}`;
  }

  function businessDaysBetween(startDate, endDate) {
    const start = new Date(startDate);
    const end = new Date(endDate);
    if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) return null;
    start.setHours(0, 0, 0, 0);
    end.setHours(0, 0, 0, 0);
    if (end <= start) return 0;
    let days = 0;
    const cursor = new Date(start);
    while (cursor < end) {
      cursor.setDate(cursor.getDate() + 1);
      const day = cursor.getDay();
      if (day !== 0 && day !== 6) days += 1;
    }
    return days;
  }

  function freshnessBadge(dateStr) {
    if (!dateStr) return { label: t("missingData"), className: "neutral" };
    const dt = new Date(dateStr);
    if (Number.isNaN(dt.getTime())) return { label: t("missingData"), className: "neutral" };
    const businessDays = businessDaysBetween(dt, new Date());
    if (businessDays === null) return { label: t("missingData"), className: "neutral" };
    if (businessDays <= 2) return { label: t("freshLabel"), className: "fresh" };
    if (businessDays >= 5) return { label: t("staleLabel"), className: "stale" };
    return { label: t("recentLabel"), className: "recent" };
  }

  function percentChange(history) {
    if (!Array.isArray(history) || history.length < 2) return null;
    const first = history.find((p) => typeof p?.value === "number");
    const last = [...history].reverse().find((p) => typeof p?.value === "number");
    if (!first || !last || !first.value) return null;
    return (last.value / first.value - 1) * 100;
  }

  function formatUtcDateTime(value) {
    try {
      const dt = new Date(value);
      if (Number.isNaN(dt.getTime())) return null;
      return dt.toISOString().slice(0, 16).replace("T", " ");
    } catch (e) {
      return null;
    }
  }

  function formatLocalDateTime(value) {
    try {
      const dt = new Date(value);
      if (Number.isNaN(dt.getTime())) return null;
      return dt.toLocaleString();
    } catch (e) {
      return null;
    }
  }

  function renderCrossMarketContextCard(newContext, legacyContext, conditionalStats, error) {
    const card = document.getElementById("contextCard");
    if (!card) return;

    if (newContext && newContext.series) {
      const asOf = newContext.meta?.generated_at_utc;
      const utcText = asOf ? `${t("updatedPrefix")}: ${formatUtcDateTime(asOf)} UTC` : null;
      const localText = asOf ? `${t("localTimeLabel")}: ${formatLocalDateTime(asOf)}` : null;
      const updatedBits = [utcText, localText].filter(Boolean);
      document.getElementById("contextAsOf").textContent = updatedBits.join(" / ") || "â€”";
      const metaNote = document.getElementById("contextMetaNote");
      const sources = newContext.meta?.sources || {};
      if (metaNote) {
        const sourceList = Object.values(sources).filter(Boolean).join(" Â· ");
        metaNote.textContent = sourceList ? `${t("contextSourceLabel")}: ${sourceList}` : "";
      }

      const warningEl = document.getElementById("contextWarnings");
      const warnings = Array.isArray(newContext.meta?.warnings) ? newContext.meta.warnings : [];
      if (warningEl) {
        if (warnings.length) {
          warningEl.style.display = "block";
          warningEl.innerHTML = warnings.map((w) => `âš ï¸ ${escapeHtml(w)}`).join("<br/>");
        } else {
          warningEl.style.display = "none";
          warningEl.textContent = "";
        }
      }

      const container = document.getElementById("contextItems");
      const entries = Object.entries(newContext.series || {});
      container.innerHTML = entries
        .map(([key, series]) => {
          const badge = freshnessBadge(series?.last_date);
          const change = percentChange(series?.history || []);
          const statBlock = (label, value, formatter = (v) => fmt(v, 2)) => `
            <div class="stat-block">
              <div class="stat-label">${label}</div>
              <div class="stat-value">${formatter(value)}</div>
            </div>`;
          return `
            <div class="context-item-card">
              <div class="context-row">
                <div class="context-name">${key.toUpperCase()}</div>
                <span class="pill ${badge.className}">${badge.label}</span>
              </div>
              <div class="context-row stat-pair">
                ${statBlock(t("contextValueLabel"), series?.last_value)}
                ${statBlock(t("contextDateLabel"), series?.last_date, (v) => v || "â€”")}
                ${statBlock(t("contextChangeLabel"), change, (v) => fmtPct(v, 1))}
              </div>
              <div class="context-note">${sources[key] ? `${t("contextSourceLabel")}: ${sources[key]}` : ""}</div>
              <div class="context-note">${t("contextDisclaimer")}</div>
            </div>
          `;
        })
        .join("");

      const footer = document.getElementById("contextFooter");
      if (footer) footer.textContent = t("contextFooter");
      card.style.display = entries.length ? "block" : "none";
      return;
    }

    if (error) {
      renderCardError("contextCard", t("contextTitle"), error);
      return;
    }

    renderLegacyContextPanel(legacyContext, conditionalStats, error);
  }

  function renderLegacyContextPanel(currentContext, conditionalStats, error) {
    const card = document.getElementById("contextCard");
    if (!card) return;
    const metaNote = document.getElementById("contextMetaNote");
    if (metaNote) metaNote.textContent = "";
    const warningEl = document.getElementById("contextWarnings");
    if (warningEl) { warningEl.style.display = "none"; warningEl.textContent = ""; }
    if (error) { renderCardError("contextCard", t("contextTitle"), error); return; }
    if (!currentContext || !Array.isArray(currentContext.items) || !currentContext.items.length) {
      card.style.display = "none";
      return;
    }
    card.style.display = "block";
    const baseline = currentContext.baseline;
    const baselineText = baseline ? `z=${baseline.window_z} Â· pct=${baseline.window_pct}` : "";
    document.getElementById("contextAsOf").textContent = currentContext.asof
      ? `${t("updatedPrefix")}: ${currentContext.asof}${baselineText ? ` (${baselineText})` : ""}`
      : "â€”";
    const container = document.getElementById("contextItems");
    container.innerHTML = currentContext.items
      .map((item) => {
        const bucket = item.band || item.bucket;
        const stats = bucket ? conditionalStats?.[item.key]?.[bucket] || item.stats : null;
        const pctText = item.pct === null || item.pct === undefined ? "â€”" : `${item.pct.toFixed(1)}p`;
        const confidence = stats?.confidence || item.confidence || "low";
        const sampleSize = stats?.n ?? item.n_band ?? 0;
        const lowSample = confidence === "low" || (baseline && sampleSize < baseline.min_occurrences);
        const statBlock = (label, value, formatter = (v) => fmt(v, 2)) => `
          <div class="stat-block">
            <div class="stat-label">${label}</div>
            <div class="stat-value">${formatter(value)}</div>
          </div>`;
        const localizedNote = localizeCopy(item.note, "contextFooter");
        return `
          <div class="context-item-card ${lowSample ? "context-low-confidence" : ""}">
            <div class="context-row">
              <div class="context-name">${item.name || item.key}</div>
              <span class="pill ${bandClass(bucket)}">${bandLabel(bucket)}</span>
            </div>
            <div class="context-row stat-pair">
              ${statBlock(t("contextValueLabel"), item.value)}
              ${statBlock(t("contextZLabel"), item.z)}
              ${statBlock(t("contextPctLabel"), pctText, (v) => v)}
            </div>
            <div class="context-row stat-pair">
              ${statBlock(t("contextPUp5d"), stats?.p_up_5d, (v) => fmtPct(v, 1))}
              ${statBlock(t("contextMedian5d"), stats?.median_5d, (v) => fmtPct(v, 2))}
            </div>
            <div class="context-row stat-pair">
              ${statBlock(t("contextPUp10d"), stats?.p_up_10d, (v) => fmtPct(v, 1))}
              ${statBlock(t("contextMedian10d"), stats?.median_10d, (v) => fmtPct(v, 2))}
            </div>
            <div class="context-row">
              <div class="stat-label">n=${sampleSize}</div>
              <span class="chip muted">${t("confidenceLabel")}: ${confidence}</span>
            </div>
            ${lowSample ? `<div class="context-warning">${t("contextLowSample")}</div>` : ""}
            <div class="context-note">${localizedNote}</div>
            <div class="context-note">${t("contextDisclaimer")}</div>
          </div>
        `;
      })
      .join("");
    const footer = document.getElementById("contextFooter");
    if (footer) footer.textContent = localizeCopy(currentContext.note, "contextFooter");
  }

  function bandLabel(band) {
    if (!band) return "â€”";
    return band.replace(/_/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
  }

  function bandClass(band) {
    if (!band) return "neutral";
    const key = band.toLowerCase();
    if (key.includes("extreme_high")) return "extreme-high";
    if (key === "high") return "high";
    if (key === "neutral") return "neutral";
    if (key === "low") return "low";
    if (key.includes("extreme_low")) return "extreme-low";
    return "neutral";
  }

  function clamp(val, min, max) {
    return Math.min(Math.max(val, min), max);
  }

  function renderDeviationPanel() {
    const payload = heatmaps.deviation;
    const latest = payload?.latest;
    const band = latest?.band;
    const tag = document.getElementById("bandStateTag");
    tag.textContent = bandLabel(band);
    tag.className = `pill ${bandClass(band)}`;

    document.getElementById("zNow").textContent = fmt(latest?.z, 2);
    document.getElementById("pctNow").textContent = latest?.pct === undefined || latest?.pct === null ? "â€”" : `${latest.pct.toFixed(1)}p`;
    document.getElementById("bandLabelNow").textContent = bandLabel(band);
    document.getElementById("zWindowLabel").textContent = payload ? `${t("stdLabel")}: ${payload.std_window}` : "â€”";
    document.getElementById("pctWindowLabel").textContent = payload ? `${t("pctNowLabel")}: ${payload.percentile_window}` : "â€”";
    document.getElementById("bandHint").textContent = t("heatmapNote");

    const baselineDesc = payload?.baseline ? `${payload.baseline.type}${payload.baseline.window}` : "â€”";
    document.getElementById("deviationMeta").textContent = payload ? `${baselineDesc} Â· Ïƒ=${payload.std_window} Â· pct=${payload.percentile_window}` : "â€”";

    const pointer = document.getElementById("zPointer");
    const zVal = typeof latest?.z === "number" ? clamp(latest.z, -3, 3) : 0;
    const pos = ((zVal + 3) / 6) * 100;
    pointer.style.left = `${pos}%`;

    const stats = band && heatmaps.stats?.bands ? heatmaps.stats.bands[band] : null;
    if (stats && stats.n) {
      const up5 = stats.p_up_5d;
      const med5 = stats.median_5d;
      document.getElementById("bandContext").textContent = `Among ${stats.n} days in ${bandLabel(band)}, P(up 5d)=${fmtPct(up5, 1)}, median 5d=${fmtPct(med5, 2)}.`;
    } else {
      document.getElementById("bandContext").textContent = t("heatmapNote");
    }
  }

  function isoWeekKey(dateStr) {
    const d = new Date(dateStr);
    const day = d.getUTCDay() || 7;
    d.setUTCDate(d.getUTCDate() + 4 - day);
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
    return `${d.getUTCFullYear()}-W${String(weekNo).padStart(2, "0")}`;
  }

  function aggregateWeekly(rows) {
    const buckets = {};
    rows.forEach((row) => {
      if (!row?.date) return;
      const key = isoWeekKey(row.date);
      buckets[key] = row;
    });
    return Object.values(buckets).sort((a, b) => new Date(a.date) - new Date(b.date));
  }

  function mapBandValue(band, mapping) {
    if (!band) return null;
    return mapping[band] ?? null;
  }

  function formatHeatmapTooltip(row, mode, bandKey, mappedValue) {
    if (!row?.date) return t("heatmapMissingData");

    const parts = [`<strong>${t("heatmapTooltipDate")}:<\/strong> ${row.date}`];
    const metrics = [];

    if (row.close !== null && row.close !== undefined) {
      metrics.push(`<strong>${t("heatmapTooltipClose")}:<\/strong> ${fmt(row.close, 2)}`);
    }

    if (mode === "deviation") {
      if (row.z !== null && row.z !== undefined) {
        metrics.push(`<strong>${t("heatmapTooltipZScore")}:<\/strong> ${fmt(row.z, 2)}`);
      }
      if (row.pct !== null && row.pct !== undefined) {
        metrics.push(`<strong>${t("heatmapTooltipPercentile")}:<\/strong> ${fmt(row.pct, 1)}`);
      }
    } else if (mode === "volatility") {
      if (row.atr_pct !== null && row.atr_pct !== undefined) {
        metrics.push(`<strong>${t("heatmapTooltipAtrPct")}:<\/strong> ${fmtPct(row.atr_pct, 2)}`);
      }
    } else if (mode === "momentum") {
      if (row.roc_20 !== null && row.roc_20 !== undefined) {
        metrics.push(`<strong>${t("heatmapTooltipRoc20")}:<\/strong> ${fmtPct(row.roc_20, 2)}`);
      }
    }

    if (metrics.length) parts.push(metrics.join(" Â· "));

    const meaning = bandMeaning(mode, bandKey);
    if (bandKey || meaning) {
      const pieces = [`<strong>${t("bandLabel")}:<\/strong> ${bandLabel(bandKey)}`];
      if (meaning) pieces.push(`${t("heatmapTooltipMeaning")}: ${meaning}`);
      parts.push(pieces.join(" Â· "));
    }

    const hasValue =
      metrics.length > 0 ||
      bandKey ||
      meaning ||
      (mappedValue !== null && mappedValue !== undefined);

    if (!hasValue) {
      parts.push(`<span class="muted">${t("heatmapMissingData")}<\/span>`);
    }

    return parts.join("<br>");
  }

  function bandMeaning(mode, band) {
    if (!band) return null;
    const keyMap = {
      deviation: {
        EXTREME_LOW: "heatmapMeaningExtremeLowDeviation",
        LOW: "heatmapMeaningLowDeviation",
        NEUTRAL: "heatmapMeaningNeutralDeviation",
        HIGH: "heatmapMeaningHighDeviation",
        EXTREME_HIGH: "heatmapMeaningExtremeHighDeviation",
      },
      volatility: {
        LOW: "heatmapMeaningLowVol",
        NORMAL: "heatmapMeaningNormalVol",
        HIGH: "heatmapMeaningHighVol",
      },
      momentum: {
        BEARISH: "heatmapMeaningBearishMom",
        NEUTRAL: "heatmapMeaningNeutralMom",
        BULLISH: "heatmapMeaningBullishMom",
      },
    };
    const meaningKey = keyMap[mode]?.[band];
    return meaningKey ? t(meaningKey) : null;
  }

  function heatmapLegendConfig(mode) {
    if (mode === "deviation") {
      return [
        { color: "#1d4ed8", label: t("heatmapMeaningExtremeLowDeviation") },
        { color: "#60a5fa", label: t("heatmapMeaningLowDeviation") },
        { color: "#6b7280", label: t("heatmapMeaningNeutralDeviation") },
        { color: "#fb923c", label: t("heatmapMeaningHighDeviation") },
        { color: "#ef4444", label: t("heatmapMeaningExtremeHighDeviation") },
      ];
    }
    if (mode === "volatility") {
      return [
        { color: "#60a5fa", label: t("heatmapMeaningLowVol") },
        { color: "#6b7280", label: t("heatmapMeaningNormalVol") },
        { color: "#f59e0b", label: t("heatmapMeaningHighVol") },
      ];
    }
    return [
      { color: "#ef4444", label: t("heatmapMeaningBearishMom") },
      { color: "#6b7280", label: t("heatmapMeaningNeutralMom") },
      { color: "#22c55e", label: t("heatmapMeaningBullishMom") },
    ];
  }

  function renderHeatmapLegend(mode) {
    const legendEl = document.getElementById("heatmapLegend");
    if (!legendEl) return;
    const items = heatmapLegendConfig(mode);
    legendEl.innerHTML = [
      `<span class="muted">${t("heatmapLegendTitle")}:</span>`,
      ...items.map(
        (item) =>
          `<span class="legend-item"><span class="legend-swatch" style="background:${item.color};"></span><span>${item.label}</span></span>`,
      ),
    ].join(" ");
  }

  function renderHeatmap() {
    const mode = state.heatmapMode;
    const payload = heatmaps[mode];
    const rows = Array.isArray(payload?.rows) ? payload.rows.filter((r) => r && r.date) : [];
    const noteEl = document.getElementById("heatmapNote");
    renderHeatmapLegend(mode);
    if (!rows.length) {
      document.getElementById("heatmap").textContent = t("perfSeriesUnavailable");
      noteEl.textContent = t("heatmapNote");
      return;
    }

    const months = state.heatmapRange === "3m" ? 3 : state.heatmapRange === "1y" ? 12 : null;
    let filtered = state.heatmapWeekly ? aggregateWeekly(rows) : rows.slice();
    if (months) {
      const last = filtered[filtered.length - 1];
      if (!last?.date) return;
      const lastDate = new Date(last.date);
      const start = new Date(lastDate);
      start.setMonth(start.getMonth() - months);
      filtered = filtered.filter((r) => r?.date && new Date(r.date) >= start);
    }

    const mapping =
      mode === "deviation"
        ? { EXTREME_LOW: -2, LOW: -1, NEUTRAL: 0, HIGH: 1, EXTREME_HIGH: 2 }
        : { LOW: -1, NORMAL: 0, HIGH: 1, BEARISH: -1, NEUTRAL: 0, BULLISH: 1 };

    const x = [];
    const values = [];
    const text = [];

    filtered.forEach((r) => {
      x.push(r.date);
      const bandKey = mode === "deviation" ? r.band : mode === "volatility" ? r.vol_bucket : r.mom_bucket;
      const mappedValue = mapBandValue(bandKey, mapping);
      values.push(mappedValue);
      text.push(formatHeatmapTooltip(r, mode, bandKey, mappedValue));
    });

    const colorscale =
      mode === "deviation"
        ? [
            [0, "#1d4ed8"],
            [0.25, "#60a5fa"],
            [0.5, "#6b7280"],
            [0.75, "#fb923c"],
            [1, "#ef4444"],
          ]
        : mode === "volatility"
          ? [
              [0, "#60a5fa"],
              [0.5, "#6b7280"],
              [1, "#f59e0b"],
            ]
          : [
              [0, "#ef4444"],
              [0.5, "#6b7280"],
              [1, "#22c55e"],
            ];

    const zmin = mode === "deviation" ? -2 : -1;
    const zmax = mode === "deviation" ? 2 : 1;
    Plotly.newPlot(
      "heatmap",
      [
        {
          x,
          y: [mode === "deviation" ? "Deviation" : mode === "volatility" ? "Vol" : "Momentum"],
          z: [values],
          text: [text],
          type: "heatmap",
          colorscale,
          hovertemplate: "%{text}<extra></extra>",
          showscale: false,
          zmin,
          zmax,
        },
      ],
      {
        paper_bgcolor: "rgba(0,0,0,0)",
        plot_bgcolor: "rgba(0,0,0,0)",
        margin: { l: 45, r: 10, t: 10, b: 40 },
        xaxis: { showgrid: false, color: "#a8b4d6" },
        yaxis: { showgrid: false, color: "#a8b4d6" },
      },
      { displayModeBar: false },
    );

    const baseline = payload?.baseline ? `${payload.baseline.type}${payload.baseline.window}` : "";
    if (mode === "deviation") {
      noteEl.textContent = `${t("heatmapNote")}${baseline ? ` Â· Baseline ${baseline}` : ""}`;
    } else if (mode === "volatility") {
      noteEl.textContent = `${t("heatmapNote")} Â· ATR% low=${fmt(payload?.thresholds?.low, 4)}, high=${fmt(payload?.thresholds?.high, 4)}`;
    } else {
      noteEl.textContent = `${t("heatmapNote")} Â· ROC20 bear=${fmtPct(payload?.thresholds?.bear, 2)}, bull=${fmtPct(payload?.thresholds?.bull, 2)}`;
    }
  }

  function renderBandStats() {
    const stats = heatmaps.stats;
    const container = document.getElementById("bandStats");
    if (!stats || !stats.bands) {
      container.textContent = t("perfSeriesUnavailable");
      return;
    }
    const order = ["EXTREME_HIGH", "HIGH", "NEUTRAL", "LOW", "EXTREME_LOW"];
    container.innerHTML = order
      .map((band) => {
        const s = stats.bands[band];
        if (!s) return "";
        const label = bandLabel(band);
        return `
          <div class="band-card">
            <div class="title"><span class="pill ${bandClass(band)}">${label}</span><span class="muted">n=${s.n}</span></div>
            <div class="stat">P(up 5d): ${fmtPct(s.p_up_5d, 1)} Â· Median 5d: ${fmtPct(s.median_5d, 2)}</div>
            <div class="stat">P(up 10d): ${fmtPct(s.p_up_10d, 1)} Â· Median 10d: ${fmtPct(s.median_10d, 2)}</div>
          </div>
        `;
      })
      .join("");
  }

  function attachHeatmapControls() {
    document.querySelectorAll("[data-heatmap]").forEach((btn) => {
      btn.addEventListener("click", () => {
        document.querySelectorAll("[data-heatmap]").forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        state.heatmapMode = btn.getAttribute("data-heatmap");
        renderHeatmap();
      });
    });

    document.querySelectorAll("[data-heatmap-range]").forEach((btn) => {
      btn.addEventListener("click", () => {
        document.querySelectorAll("[data-heatmap-range]").forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        state.heatmapRange = btn.getAttribute("data-heatmap-range");
        renderHeatmap();
      });
    });

    const weekly = document.getElementById("heatmapWeekly");
    weekly.addEventListener("change", (e) => {
      state.heatmapWeekly = e.target.checked;
      renderHeatmap();
    });
  }

  function renderMeta() {
    const symbolText = meta?.symbol ? ` (${meta.symbol})` : "";
    const sourceText = meta?.source ? `${meta.source}${symbolText}` : "â€”";
    const coverageCore = meta?.start && meta?.end ? `${meta.start} â†’ ${meta.end}` : "â€”";
    const rowsSuffix = Number.isFinite(meta?.rows) ? ` (${Number(meta.rows).toLocaleString()})` : "";
    const snapshot = meta?.snapshot || {};
    const snapshotStatus = snapshot?.source_status || "unknown";
    const snapshotStatusLabel = snapshotStatus === "live"
      ? t("snapshotStatusLive")
      : snapshotStatus === "cached"
        ? t("snapshotStatusCached")
        : t("snapshotStatusUnknown");
    const snapshotFetchedAt = snapshot?.fetched_at_utc || meta?.last_updated_utc;

    document.getElementById("metaSource").textContent = sourceText;
    document.getElementById("metaCoverage").textContent = coverageCore === "â€”" ? "â€”" : `${coverageCore}${rowsSuffix}`;
    document.getElementById("metaUpdated").textContent = meta?.last_updated_utc ?? "â€”";
    document.getElementById("metaSnapshotStatus").textContent = snapshotFetchedAt ? snapshotStatusLabel : "â€”";
    document.getElementById("metaSnapshotAge").textContent = formatSnapshotAge(snapshotFetchedAt);

    const snapshotNote = document.getElementById("metaSnapshotNote");
    if (snapshotNote) {
      if (snapshot?.error_reason) {
        snapshotNote.textContent = `${t("snapshotErrorPrefix")}: ${snapshot.error_reason}`;
        snapshotNote.style.display = "block";
      } else {
        snapshotNote.textContent = "";
        snapshotNote.style.display = "none";
      }
    }
  }

  function getRangeMask(months, startDate, endDate) {
    const mask = [];
    const startBound = startDate ? new Date(startDate) : null;
    const endBound = endDate ? new Date(endDate) : null;
    const rangeStart = (() => {
      if (!months) return null;
      const lastDate = priceDates[priceDates.length - 1];
      if (!lastDate) return null;
      const start = new Date(lastDate);
      start.setMonth(start.getMonth() - months);
      return start;
    })();

    priceDates.forEach((d, i) => {
      if (rangeStart && d < rangeStart) return;
      if (startBound && d < startBound) return;
      if (endBound && d > endBound) return;
      mask.push(i);
    });
    return mask;
  }

  function applyMask(arr, mask, accessor) {
    if (!Array.isArray(arr)) return [];
    return mask
      .map((i) => {
        const value = arr[i];
        if (value === undefined) return undefined;
        return accessor ? accessor(value, i) : value;
      })
      .filter((v) => v !== undefined);
  }

  function renderPrice(range) {
    const months = range === "3m" ? 3 : range === "1y" ? 12 : null;
    const mask = getRangeMask(months, state.startDate, state.endDate);
    const dates = applyMask(prices.dates, mask);
    const close = applyMask(prices.close, mask);

    const opens = close.map((c, i) => (i === 0 ? c : close[i - 1]));
    const highs = close.map((c, i) => Math.max(c, opens[i]) * 1.002);
    const lows = close.map((c, i) => Math.min(c, opens[i]) * 0.998);

    const candle = { x: dates, open: opens, high: highs, low: lows, close, type: "candlestick", name: "SLV", increasing: { line: { color: "#22c55e" } }, decreasing: { line: { color: "#f43f5e" } } };

    const traces = [candle];
    if (state.showMa) {
      const ma20 = applyMask(movingAverage(prices.close, 20), mask);
      const ma50 = applyMask(movingAverage(prices.close, 50), mask);
      const ma200 = applyMask(movingAverage(prices.close, 200), mask);
      traces.push({ x: dates, y: ma20, mode: "lines", name: "MA20", line: { color: "#8bb2ff", width: 1.5 } });
      traces.push({ x: dates, y: ma50, mode: "lines", name: "MA50", line: { color: "#fbbf24", width: 1.2, dash: "dot" } });
      traces.push({ x: dates, y: ma200, mode: "lines", name: "MA200", line: { color: "#a855f7", width: 1.4, dash: "dash" } });
    }

    if (state.showBoll) {
      const bands = bollinger(prices.close, 20, 2);
      traces.push({ x: dates, y: applyMask(bands.upper, mask), mode: "lines", name: "Upper Band", line: { color: "rgba(255,255,255,0.35)", width: 1 } });
      traces.push({ x: dates, y: applyMask(bands.lower, mask), mode: "lines", name: "Lower Band", line: { color: "rgba(255,255,255,0.35)", width: 1 } });
    }

    const turningPoints = (cycleStats?.turning_points ?? []).filter((p) => {
      if (!p?.date) return false;
      const d = new Date(p.date);
      if (state.startDate && d < new Date(state.startDate)) return false;
      if (state.endDate && d > new Date(state.endDate)) return false;
      if (!months) return true;
      const lastPriceDate = priceDates[priceDates.length - 1];
      if (!lastPriceDate) return false;
      const start = new Date(lastPriceDate);
      start.setMonth(start.getMonth() - months);
      return d >= start;
    });

    if (state.showCycles && turningPoints.length) {
      const buys = turningPoints.filter((p) => p.kind === "trough");
      const sells = turningPoints.filter((p) => p.kind === "peak");
      traces.push({ x: buys.map((p) => p.date), y: buys.map((p) => p.close), mode: "markers", type: "scatter", name: "Trough", marker: { color: "#22c55e", size: 9, symbol: "triangle-up" } });
      traces.push({ x: sells.map((p) => p.date), y: sells.map((p) => p.close), mode: "markers", type: "scatter", name: "Peak", marker: { color: "#f43f5e", size: 9, symbol: "triangle-down" } });
    }

    const layout = { paper_bgcolor: "rgba(0,0,0,0)", plot_bgcolor: "rgba(0,0,0,0)", margin: { l: 45, r: 15, t: 20, b: 40 }, xaxis: { showgrid: false, color: "#a8b4d6" }, yaxis: { showgrid: true, gridcolor: "#1e2a45", color: "#a8b4d6" } };
    Plotly.newPlot("chart", traces, layout, { displayModeBar: false });

    const cyclesData = cycleStats?.cycles ?? [];
    const tableBody = document.querySelector("#cycleTable tbody");
    const recentCycles = cyclesData.filter((cycle) => {
      const d = new Date(cycle.end_date);
      if (state.startDate && d < new Date(state.startDate)) return false;
      if (state.endDate && d > new Date(state.endDate)) return false;
      if (!months) return true;
      const start = new Date(priceDates[priceDates.length - 1]);
      start.setMonth(start.getMonth() - months);
      return d >= start;
    }).slice(-6).reverse();

    if (tableBody) {
      if (recentCycles.length === 0) {
        tableBody.innerHTML = `<tr><td colspan="5" class="muted">${t("noCycles")}</td></tr>`;
      } else {
        tableBody.innerHTML = recentCycles.map((cycle) => {
          const dir = cycle.direction === "upswing" ? "up" : "down";
          return `
            <tr>
              <td>${cycle.end_date}</td>
              <td>${cycle.start_date}</td>
              <td><span class="pill ${dir}">${cycle.direction}</span></td>
              <td>${cycle.length}d</td>
              <td>${fmtPct(cycle.amplitude, 1)}</td>
            </tr>
          `;
        }).join("");
      }
    }
  }

  function computeRisk(series, dates) {
    if (!series?.length || !dates?.length) return { dd: null, ulcer: null, worst: null };
    const vals = series.map((p) => p?.equity ?? p);
    let peak = vals[0];
    let maxDd = 0;
    const ddSquares = [];
    vals.forEach((v) => {
      peak = Math.max(peak, v);
      const dd = (v - peak) / peak;
      maxDd = Math.min(maxDd, dd);
      ddSquares.push((dd * 100) ** 2);
    });
    const ulcer = Math.sqrt(ddSquares.reduce((a, b) => a + b, 0) / ddSquares.length);
    // monthly
    const monthMap = new Map();
    vals.forEach((v, i) => {
      const key = `${dates[i].getFullYear()}-${dates[i].getMonth() + 1}`;
      monthMap.set(key, v);
    });
    const keys = Array.from(monthMap.keys()).sort();
    let worst = null;
    for (let i = 1; i < keys.length; i++) {
      const prev = monthMap.get(keys[i - 1]);
      const curr = monthMap.get(keys[i]);
      const r = curr / prev - 1;
      if (worst === null || r < worst) worst = r;
    }
    return { dd: maxDd, ulcer, worst };
  }

  function computeStats(series) {
    if (!series?.length) return { totalReturn: null, maxDrawdown: null, sharpe: null, sortino: null };
    const vals = series.map((p) => p?.equity ?? p);
    if (!vals.length) return { totalReturn: null, maxDrawdown: null, sharpe: null, sortino: null };

    const returns = [];
    for (let i = 1; i < vals.length; i++) {
      if (!vals[i - 1]) continue;
      returns.push(vals[i] / vals[i - 1] - 1);
    }

    const totalReturn = vals[vals.length - 1] / vals[0] - 1;
    let peak = vals[0];
    let maxDd = 0;
    vals.forEach((v) => { peak = Math.max(peak, v); maxDd = Math.min(maxDd, (v - peak) / peak); });

    const mean = returns.reduce((a, b) => a + b, 0) / (returns.length || 1);
    const variance = returns.reduce((a, b) => a + (b - mean) ** 2, 0) / (returns.length || 1);
    const std = Math.sqrt(variance);
    const sharpe = std ? mean / std : 0;
    const downside = returns.filter((r) => r < 0);
    const downsideMean = downside.reduce((a, b) => a + b, 0) / (downside.length || 1);
    const downsideVariance = downside.reduce((a, b) => a + (b - downsideMean) ** 2, 0) / (downside.length || 1);
    const downsideDev = Math.sqrt(downsideVariance);
    const sortino = downsideDev ? mean / downsideDev : 0;

    return {
      totalReturn,
      maxDrawdown: maxDd,
      sharpe,
      sortino,
    };
  }

  function buildBuyHoldSeries(closes) {
    const eq = [{ index: 0, equity: 1 }];
    for (let i = 1; i < closes.length; i++) {
      const ret = closes[i] / closes[i - 1] - 1;
      eq.push({ index: i, equity: eq[i - 1].equity * (1 + ret) });
    }
    return eq;
  }

  function biasClassName(bias) {
    if (!bias) return "neutral";
    if (bias.toLowerCase().includes("bull")) return "up";
    if (bias.toLowerCase().includes("bear")) return "down";
    return "neutral";
  }

  function renderProbabilistic(data, error) {
    if (error) {
      renderCardError("snapshotCard", t("marketSnapshotTitle"), error);
      return;
    }

    if (!data) {
      document.getElementById("scenarioId").textContent = "Loadingâ€¦";
      document.getElementById("probHeadline").textContent = t("limitsCopy");
      document.getElementById("probSubtext").textContent = "";
      return;
    }

    const outcomes = data.historical_outcomes || {};
    document.getElementById("scenarioId").textContent = data.scenario_id || "â€”";
    document.getElementById("probHeadline").textContent = data.message?.headline || t("limitsCopy");
    document.getElementById("probSubtext").textContent = data.message?.subtext || "";
    document.getElementById("probConfidence").textContent = data.confidence !== undefined ? `${Number(data.confidence).toFixed(0)}%` : "â€”";
    document.getElementById("probOccurrences").textContent = outcomes.occurrences ?? "â€”";
    document.getElementById("probDisclaimer").textContent = data.disclaimer_level === "HIGH" ? t("limitsCopy") : "";

    document.getElementById("probUp").textContent = fmtPct(outcomes.p_up, 0);
    document.getElementById("probDown").textContent = fmtPct(outcomes.p_down, 0);
    document.getElementById("probMedianReturn").textContent = fmtPct(outcomes.median_return, 2);
    document.getElementById("probSpread").textContent = `${fmtPct(outcomes.p10_return, 1)} â†’ ${fmtPct(outcomes.p90_return, 1)}`;
    document.getElementById("probRange").textContent = `${fmtPct(outcomes.p10_return, 1)} â†’ ${fmtPct(outcomes.p90_return, 1)}`;
    document.getElementById("probMedian").textContent = `${t("medianLabel")}: ${fmtPct(outcomes.median_return, 1)}`;
    const horizon = outcomes.horizon_days || 5;
    const historicalText = outcomes.occurrences
      ? `${fmtPct(outcomes.p_up, 0)} of ${outcomes.occurrences} matches were up after ${horizon}d (median ${fmtPct(outcomes.median_return, 1)}).`
      : t("limitsCopy");
    document.getElementById("historicalSentence").textContent = historicalText;

    const rangeChip = document.getElementById("rangeChip");
    rangeChip.textContent = outcomes.occurrences
      ? `${outcomes.occurrences} cases Â· ${fmtPct(outcomes.p10_return, 1)} to ${fmtPct(outcomes.p90_return, 1)} after ${horizon}d`
      : t("limitsCopy");

    const evidence = data.evidence || [];
    const evidenceList = document.getElementById("probEvidence");
    if (!evidence.length) {
      evidenceList.innerHTML = `<li>${t("limitsCopy")}</li>`;
    } else {
      evidenceList.innerHTML = evidence.map((e) => `<li>${e.text}</li>`).join("");
    }

    const biasBadge = document.getElementById("biasBadge");
    const bias = data.state?.bias || "NEUTRAL";
    biasBadge.className = `pill ${biasClassName(bias)}`;
    biasBadge.textContent = bias;

    const volBadge = document.getElementById("volBadge");
    const volText = data.state?.volatility || "â€”";
    volBadge.className = `pill ${volText === "HIGH" ? "up" : volText === "LOW" ? "down" : "neutral"}`;
    volBadge.textContent = volText;
    document.getElementById("probState").textContent = data.state?.regime ? `${data.state.regime} regime` : "";

    const analogies = data.analogs || [];
    const analogyList = document.getElementById("analogyList");
    if (!analogies.length) {
      analogyList.innerHTML = `<div class="muted">${t("limitsCopy")}</div>`;
    } else {
      analogyList.innerHTML = analogies
        .map((a) => {
          return `
            <div class="analogy">
              <div class="muted">${a.start_date} Â· similarity ${fmt(a.similarity, 2)}</div>
              <div class="v mono">${fmtPct(a.forward_5d, 2)} / ${fmtPct(a.forward_10d, 2)}</div>
              <div class="small muted">${t("medianLabel")}: ${fmtPct(outcomes.median_return, 1)}</div>
            </div>
          `;
        })
        .join("");
    }
  }

  function renderProbabilityEngine(result, config, error) {
    const horizon = config?.horizon ?? 20;
    const probEl = document.getElementById("probEngineProb");
    const horizonEl = document.getElementById("probEngineHorizon");
    const medianEl = document.getElementById("probEngineMedian");
    const rangeEl = document.getElementById("probEngineRange");
    const neighborsEl = document.getElementById("probEngineNeighbors");
    const distanceEl = document.getElementById("probEngineDistance");
    const confidenceEl = document.getElementById("probEngineConfidence");
    const descriptionEl = document.getElementById("probEngineDescription");
    const neighborList = document.getElementById("probEngineTopNeighbors");
    const successFlag = document.getElementById("probEngineSuccessFlag");
    const probWrap = document.getElementById("probEngineProbWrap");

    if (error) { renderCardError("probEngineCard", t("probEngineTitle"), error); return; }
    if (!probEl || !horizonEl || !medianEl || !rangeEl || !neighborsEl || !confidenceEl || !neighborList) return;

    const reset = () => {
      probEl.textContent = "â€”";
      horizonEl.textContent = t("limitsCopy");
      medianEl.textContent = "â€”";
      rangeEl.textContent = "â€”";
      neighborsEl.textContent = "â€”";
      distanceEl.textContent = "";
      confidenceEl.textContent = t("probEngineConfidenceLow");
      descriptionEl.textContent = t("limitsCopy");
      neighborList.innerHTML = `<div class="muted">${t("limitsCopy")}</div>`;
      if (successFlag) successFlag.style.display = "none";
      if (probWrap) probWrap.classList.remove("highlight");
    };

    if (!result) {
      reset();
      return;
    }

    probEl.textContent = fmtPct(result.pSuccess, 1);
    horizonEl.textContent = `${t("rangeLabel")} ${horizon}d`;
    medianEl.textContent = fmtPct(result.stats?.median, 2);
    rangeEl.textContent = `${fmtPct(result.stats?.p10, 1)} â†’ ${fmtPct(result.stats?.p90, 1)}`;
    neighborsEl.textContent = `${result.n} Â· eff ${fmt(result.effectiveN, 0)}`;
    distanceEl.textContent = `${t("confidenceLabel")}: ${fmt(result.avgDistance, 2)}`;

    const confidenceKey =
      result.confidenceLabel === "High"
        ? "probEngineConfidenceHigh"
        : result.confidenceLabel === "Medium"
          ? "probEngineConfidenceMedium"
          : "probEngineConfidenceLow";
    confidenceEl.textContent = t(confidenceKey);
    confidenceEl.className = `chip ${result.confidenceLabel === "High" ? "info" : result.confidenceLabel === "Low" ? "muted" : ""}`.trim();

    descriptionEl.textContent = result.description || t("limitsCopy");

    const highlightThreshold = Number(config?.highlightThreshold ?? 0);
    const hit = highlightThreshold > 0 && result.pSuccess >= highlightThreshold;
    if (probWrap) probWrap.classList.toggle("highlight", hit);
    if (successFlag) {
      successFlag.style.display = hit ? "inline-flex" : "none";
      successFlag.textContent = hit
        ? `${t("probEngineHighlightHit")} (${fmtPct(highlightThreshold, 0)}+)`
        : "";
    }

    const top = Array.isArray(result.neighborsTop) ? result.neighborsTop.slice(0, 4) : [];
    if (!top.length) {
      neighborList.innerHTML = `<div class="muted">${t("limitsCopy")}</div>`;
    } else {
      neighborList.innerHTML = top
        .map((n) => {
          return `
            <div class="analogy">
              <div class="muted">${n.t}</div>
              <div class="v mono">${fmtPct(n.y, 2)}</div>
              <div class="small muted">${t("probEngineRangeLabel")}: ${fmt(n.d, 2)}</div>
            </div>
          `;
        })
        .join("");
    }
  }

  function renderProbabilitySettings(config) {
    const horizonSelect = document.getElementById("probSettingHorizon");
    const kSelect = document.getElementById("probSettingK");
    const weightingSelect = document.getElementById("probSettingWeighting");
    const thresholdSelect = document.getElementById("probSettingThreshold");
    const highlightInput = document.getElementById("probSettingHighlight");
    if (!horizonSelect || !kSelect || !weightingSelect || !thresholdSelect || !highlightInput) return;

    horizonSelect.value = String(config?.horizon ?? 20);
    kSelect.value = String(config?.k ?? 150);
    weightingSelect.value = config?.weighting ?? "inverse_distance";
    thresholdSelect.value = String(Math.round((config?.threshold ?? 0) * 100));
    highlightInput.value = Math.round((config?.highlightThreshold ?? 0) * 100);
  }

  function percentile(arr, pct) {
    if (!Array.isArray(arr) || !arr.length) return null;
    const sorted = [...arr].sort((a, b) => a - b);
    const clamped = Math.min(100, Math.max(0, pct));
    const rank = (clamped / 100) * (sorted.length - 1);
    const lower = Math.floor(rank);
    const upper = Math.ceil(rank);
    if (lower === upper) return sorted[lower];
    const weight = rank - lower;
    return sorted[lower] * (1 - weight) + sorted[upper] * weight;
  }

  function buildIndicatorLookup(series, key) {
    if (!Array.isArray(series)) return {};
    const lookup = {};
    series.forEach((row) => {
      if (!row) return;
      const k = row.date || (row.index !== undefined ? String(row.index) : null);
      const v = key ? row[key] : null;
      if (k !== null && v !== undefined && v !== null) lookup[k] = Number(v);
    });
    return lookup;
  }

  function runBacktest(closes, dates, options) {
    const ma = movingAverage(closes, options.maWindow || 50);
    const bands = bollinger(closes, options.bandWindow || 20, options.bandStd || 2);
    const rsi = computeRsi(closes, options.rsiPeriod || 14);
    const atrLookup = buildIndicatorLookup(options.atrSeries, "atr");
    const adxLookup = buildIndicatorLookup(options.adxSeries, "adx");

    const gross = [{ index: 0, equity: 1 }];
    const net = [{ index: 0, equity: 1 }];
    const trades = [];
    const returns = closes.map((c, i) => (i === 0 ? 0 : (c / (closes[i - 1] || 1)) - 1));
    const costRate = ((options.costBps || 0) + (options.slippageBps || 0)) / 10000;
    const targetVol = (Number(options.targetDailyVol) || 0) / 100;
    const stopMult = Number(options.stopAtrMult) || 0;
    const trailMult = Number(options.trailingAtrMult) || 0;
    const riskBudget = (Number(options.varRisk) || 0) / 100;
    const varLookback = Math.max(10, Number(options.varLookback) || 60);
    const varTailPct = 100 - (Number(options.varConfidence) || 95);

    let equityGross = 1;
    let equityNet = 1;
    let inPosition = false;
    let position = 0;
    let entryIndex = null;
    let entryGross = 1;
    let entryNet = 1;
    let entryPrice = 0;
    let entryAtr = null;
    let peakPrice = 0;

    const clampSize = (v) => Math.max(0, Math.min(1, Number(v)));

    const sizeForIndex = (i) => {
      let size = 1;
      const atrValue = atrLookup[dates[i]] ?? null;
      const adxValue = adxLookup[dates[i]] ?? null;
      const close = closes[i];
      if (options.useAtrSizing && atrValue !== null && close) {
        const atrPct = atrValue / close;
        if (atrPct > 0 && targetVol > 0) {
          size = Math.min(size, targetVol / atrPct);
        }
      }

      if (options.useVarSizing && i > 2) {
        const start = Math.max(1, i - varLookback);
        const window = returns.slice(start, i + 1);
        const tail = percentile(window, varTailPct);
        if (tail !== null && tail < 0 && riskBudget > 0) {
          const sizeFromVar = riskBudget / Math.abs(tail);
          size = Math.min(size, sizeFromVar);
        }
      }

      if (adxValue !== null && adxValue < 15) size *= 0.75;

      return clampSize(size);
    };

    const recordExit = (i, reason) => {
      equityNet *= 1 - costRate * position;
      const grossRet = equityGross / entryGross - 1;
      const netRet = equityNet / entryNet - 1;
      trades.push({
        entry: dates[entryIndex],
        exit: dates[i],
        reason,
        return: netRet,
        gross_return: grossRet,
        hold: i - entryIndex,
        size: Number(position.toFixed(4)),
      });
      inPosition = false;
      position = 0;
      entryIndex = null;
      entryPrice = 0;
      entryAtr = null;
      peakPrice = 0;
    };

    for (let i = 1; i < closes.length; i++) {
      const maVal = ma[i];
      const rsiVal = rsi[i];
      const lower = bands.lower[i];

      if (inPosition) {
        const ret = returns[i];
        equityGross *= 1 + ret * position;
        equityNet *= 1 + ret * position;
        peakPrice = Math.max(peakPrice, closes[i]);
      }

      gross.push({ index: i, equity: Number(equityGross.toFixed(6)) });
      net.push({ index: i, equity: Number(equityNet.toFixed(6)) });

      const atrForEntry = entryAtr ?? (entryIndex !== null ? atrLookup[dates[entryIndex]] : null);
      const stopLoss = inPosition && options.useStopLoss && atrForEntry !== null && closes[i] <= entryPrice - stopMult * atrForEntry;
      const trailingStop =
        inPosition && options.useTrailingStop && atrForEntry !== null && peakPrice && closes[i] <= peakPrice - trailMult * atrForEntry;
      const exitMa = inPosition && maVal !== null && closes[i] < maVal;
      const exitRsi = inPosition && rsiVal !== null && rsiVal >= (options.rsiOverbought || 65);

      if (inPosition && (exitMa || exitRsi || stopLoss || trailingStop)) {
        const reason = stopLoss
          ? "ATR stop"
          : trailingStop
          ? "Trailing stop"
          : exitRsi
          ? "RSI exit"
          : "MA breakdown";
        recordExit(i, reason);
        continue;
      }

      const entryBand = lower !== null && closes[i] <= lower;
      const entryRsi = rsiVal !== null && rsiVal <= (options.rsiOversold || 35);
      const entryTrend = maVal !== null && closes[i] >= maVal * 0.98;
      if (!inPosition && entryBand && entryRsi && entryTrend) {
        const size = sizeForIndex(i);
        if (size <= 0) continue;
        inPosition = true;
        position = size;
        entryIndex = i;
        entryPrice = closes[i];
        entryGross = equityGross;
        equityNet *= 1 - costRate * position;
        entryNet = equityNet;
        entryAtr = atrLookup[dates[i]] ?? null;
        peakPrice = entryPrice;
      }
    }

    if (inPosition && entryIndex !== null) {
      recordExit(closes.length - 1, "Range timeout");
    }

    const buyHold = buildBuyHoldSeries(closes);

    return {
      gross,
      net,
      buyHold,
      trades,
      stats: {
        strategy: computeStats(net),
        strategyGross: computeStats(gross),
        benchmark: computeStats(buyHold),
      },
    };
  }

  function renderEquity(range) {
    const months = range === "3m" ? 3 : range === "1y" ? 12 : null;
    const mask = getRangeMask(months, state.startDate, state.endDate);
    const dates = applyMask(prices.dates, mask, (d) => new Date(d));
    const close = applyMask(prices.close, mask, (v) => v);
    if (!close.length) { document.getElementById("perfChart").textContent = t("perfSeriesUnavailable"); return; }

    const seriesReturn = (series) => series?.length ? series[series.length - 1].equity / (series[0].equity || 1) - 1 : null;
    const hasPrecomputed = Array.isArray(backtestEquity?.rows) && backtestEquity.rows.length;
    const tradesCount = backtestFeesImpact?.totals?.num_trades ?? (backtestTradeLog?.trades?.length ?? 0);
    const sensitivityAvailable = (backtestFeesSensitivity?.rows?.length ?? 0) > 0 && tradesCount > 0;
    const useCustomBacktest = state.useCustomBacktest || !hasPrecomputed;
    if (!sensitivityAvailable) state.showSensitivity = false;
    const sensToggle = document.getElementById("toggleFeesSensitivity");
    if (sensToggle) {
      sensToggle.checked = state.showSensitivity && sensitivityAvailable;
      sensToggle.disabled = !sensitivityAvailable;
    }

    if (hasPrecomputed && !useCustomBacktest) {
      const equityRows = backtestEquity.rows;
      const datesMasked = applyMask(equityRows, mask, (r) => new Date(r.date));
      const gross = applyMask(equityRows, mask, (r) => ({ equity: r.strategy_gross }));
      const net = applyMask(equityRows, mask, (r) => ({ equity: r.strategy_net }));
      const buyHold = applyMask(equityRows, mask, (r) => ({ equity: r.buy_hold }));

      const useSensitivity = state.showSensitivity && sensitivityAvailable;
      const baseNetSeries = net;
      const grossReturn = seriesReturn(gross);
      const netReturn = seriesReturn(baseNetSeries);
      const drag = netReturn !== null && grossReturn !== null ? netReturn - grossReturn : null;

      let chosen = state.showNet ? baseNetSeries : gross;
      let traces = [
        { x: datesMasked, y: chosen.map((p) => p.equity), mode: "lines", name: state.showNet ? "Strategy (Net)" : "Strategy (Gross)", line: { color: "#4c9cff" } },
      ];

      if (useSensitivity) {
        const sensMasked = applyMask(backtestFeesSensitivity.rows, mask, (r) => r);
        const seriesFor = (key) => sensMasked.map((row) => ({ equity: row?.[key] ?? 0 }));
        const netLow = seriesFor("net_low");
        const netBase = seriesFor("net_base");
        const netHigh = seriesFor("net_high");
        chosen = netBase;
        traces = [
          { x: datesMasked, y: netLow.map((p) => p.equity), mode: "lines", name: "Net (low fees)", line: { color: "#10b981", dash: "dot" } },
          { x: datesMasked, y: netBase.map((p) => p.equity), mode: "lines", name: "Net (base)", line: { color: "#4c9cff" } },
          { x: datesMasked, y: netHigh.map((p) => p.equity), mode: "lines", name: "Net (high fees)", line: { color: "#f43f5e", dash: "dash" } },
        ];
      }

      traces.push({ x: datesMasked, y: buyHold.map((p) => p.equity), mode: "lines", name: "Buy & Hold", line: { color: "#fbbf24", dash: "dot" } });

      const layout = { paper_bgcolor: "rgba(0,0,0,0)", plot_bgcolor: "rgba(0,0,0,0)", margin: { l: 45, r: 15, t: 20, b: 40 }, xaxis: { showgrid: false, color: "#a8b4d6" }, yaxis: { showgrid: true, gridcolor: "#1e2a45", color: "#a8b4d6" } };
      Plotly.newPlot("perfChart", traces, layout, { displayModeBar: false });

      const selectedStats = computeStats(chosen);
      const benchStats = computeStats(buyHold);
      const riskSeries = computeRisk(chosen, datesMasked);
      const riskSummary = backtestRiskMetrics?.summary ?? {};
      const risk = {
        dd: riskSeries.dd ?? riskSummary.max_drawdown ?? null,
        ulcer: riskSeries.ulcer ?? riskSummary.ulcer_index ?? null,
        worst: riskSeries.worst ?? riskSummary.worst_month ?? null,
      };
      document.getElementById("riskDd").textContent = fmtPct(risk.dd, 2);
      document.getElementById("riskUlcer").textContent = fmt(risk.ulcer, 2);
      document.getElementById("riskWorst").textContent = fmtPct(risk.worst, 2);

      const perfBody = document.getElementById("perfTableBody");
      const chosenReturn = selectedStats.totalReturn;
      const benchReturn = benchStats.totalReturn;
      const maxDdDisplay = fmtPct(selectedStats.maxDrawdown ?? risk.dd, 2);

      perfBody.innerHTML = `
        <tr><td>${state.showSensitivity ? "Strategy (net scenarios)" : state.showNet ? "Strategy (Net)" : "Strategy (Gross)"}</td><td>${fmtPct(chosenReturn, 2)}</td><td>${maxDdDisplay}</td><td>${fmt(selectedStats.sharpe, 2)}</td><td>${fmt(selectedStats.sortino, 2)}</td></tr>
        <tr><td>${t("buyHoldLabel")}</td><td>${fmtPct(benchReturn, 2)}</td><td>${fmtPct(benchStats.maxDrawdown, 2)}</td><td>${fmt(benchStats.sharpe, 2)}</td><td>${fmt(benchStats.sortino, 2)}</td></tr>
      `;

      const roundTrip = backtestEquity.fees?.round_trip_bps ?? null;
      document.getElementById("roundTripBps").textContent = roundTrip !== null ? `${roundTrip} bps` : "â€”";
      document.getElementById("numTrades").textContent = tradesCount || 0;
      const feesTotal = backtestFeesImpact?.totals?.total_fees_currency;
      const feesPct = backtestFeesImpact?.totals?.total_fees_pct;
      document.getElementById("feesTotal").textContent = feesTotal !== undefined ? `${fmt(feesTotal, 4)} (${fmtPct(feesPct, 3)})` : "â€”";
      document.getElementById("feeDragVal").textContent = fmtPct(backtestFeesImpact?.totals?.fee_drag_pct_points, 3);
      document.getElementById("grossReturnVal").textContent = fmtPct(backtestFeesImpact?.totals?.gross_total_return ?? grossReturn, 2);
      document.getElementById("netReturnVal").textContent = fmtPct(backtestFeesImpact?.totals?.net_total_return ?? netReturn, 2);

      const feesNote = document.getElementById("feesNote");
      const feesBody = document.getElementById("feesImpactBody");
      if (!tradesCount) {
        feesNote.textContent = t("noTradesFees");
        feesBody.style.opacity = 0.6;
      } else {
        feesNote.textContent = "";
        feesBody.style.opacity = 1;
      }

      return;
    }

    const backtest = runBacktest(close, dates, { ...state, atrSeries, adxSeries });
    lastBacktest = backtest;
    const gross = backtest.gross;
    const buyHold = backtest.buyHold;
    const net = backtest.net ?? applyCosts(gross, state.costBps + state.slippageBps);
    const grossStats = backtest.stats.strategyGross ?? backtest.stats.strategy;
    const netStats = backtest.stats.strategy ?? computeStats(net);
    const benchStats = backtest.stats.benchmark;
    const selectedStats = state.showNet ? netStats : grossStats;

    const chosen = state.showNet ? net : gross;
    const grossReturn = gross.length ? gross[gross.length - 1].equity - 1 : null;
    const netReturn = net.length ? net[net.length - 1].equity - 1 : null;
    const drag = grossReturn !== null && netReturn !== null ? netReturn - grossReturn : null;

    const traces = [
      { x: dates, y: chosen.map((p) => p.equity), mode: "lines", name: state.showNet ? "Strategy (Net)" : "Strategy (Gross)", line: { color: "#4c9cff" } },
      { x: dates, y: buyHold.map((p) => p.equity), mode: "lines", name: "Buy & Hold", line: { color: "#fbbf24", dash: "dot" } },
    ];

    const layout = { paper_bgcolor: "rgba(0,0,0,0)", plot_bgcolor: "rgba(0,0,0,0)", margin: { l: 45, r: 15, t: 20, b: 40 }, xaxis: { showgrid: false, color: "#a8b4d6" }, yaxis: { showgrid: true, gridcolor: "#1e2a45", color: "#a8b4d6" } };
    Plotly.newPlot("perfChart", traces, layout, { displayModeBar: false });

    const risk = computeRisk(chosen, dates);
    document.getElementById("riskDd").textContent = fmtPct(risk.dd, 2);
    document.getElementById("riskUlcer").textContent = fmt(risk.ulcer, 2);
    document.getElementById("riskWorst").textContent = fmtPct(risk.worst, 2);

    document.getElementById("feeDragVal").textContent = fmtPct(drag, 2);
    document.getElementById("grossReturnVal").textContent = fmtPct(grossReturn, 2);
    document.getElementById("netReturnVal").textContent = fmtPct(netReturn, 2);

    const perfBody = document.getElementById("perfTableBody");
    const chosenReturn = selectedStats.totalReturn;
    const benchReturn = benchStats.totalReturn;
    const maxDdDisplay = fmtPct(selectedStats.maxDrawdown ?? risk.dd, 2);

    perfBody.innerHTML = `
      <tr><td>${state.showNet ? "Strategy (Net)" : "Strategy (Gross)"}</td><td>${fmtPct(chosenReturn, 2)}</td><td>${maxDdDisplay}</td><td>${fmt(selectedStats.sharpe, 2)}</td><td>${fmt(selectedStats.sortino, 2)}</td></tr>
      <tr><td>${t("buyHoldLabel")}</td><td>${fmtPct(benchReturn, 2)}</td><td>${fmtPct(benchStats.maxDrawdown, 2)}</td><td>${fmt(benchStats.sharpe, 2)}</td><td>${fmt(benchStats.sortino, 2)}</td></tr>
    `;

    document.getElementById("roundTripBps").textContent = `${(state.costBps + state.slippageBps) * 2} bps`;
    document.getElementById("numTrades").textContent = backtest.trades?.length ?? 0;
    const feesTotalEl = document.getElementById("feesTotal");
    if (feesTotalEl) feesTotalEl.textContent = `${fmtPct(drag, 2)} drag vs gross`;
  }

  function renderTradeLog() {
    const tbody = document.querySelector("#tradeTable tbody");
    const trades = (backtestTradeLog?.trades ?? lastBacktest?.trades ?? []).slice(-8).reverse();
    if (!trades.length) { tbody.innerHTML = `<tr><td colspan="5" class="muted">${t("noCycles")}</td></tr>`; return; }
    const fmtDate = (d) => {
      if (!d) return "â€”";
      if (d instanceof Date) return d.toISOString().slice(0, 10);
      return String(d).slice(0, 10);
    };

    tbody.innerHTML = trades.map((trade) => {
      const entry = trade.entry_date || trade.entry;
      const exit = trade.exit_date || trade.exit;
      const reason = trade.exit_reason || trade.reason;
      const ret = trade.net_return ?? trade.return;
      const hold = trade.hold_days ?? trade.hold;
      return `<tr>
        <td>${fmtDate(entry)}</td>
        <td>${fmtDate(exit)}</td>
        <td>${reason}</td>
        <td>${fmtPct(ret, 2)}</td>
        <td>${hold}d</td>
      </tr>`;
    }).join("");
  }

  function renderSummary() {
    const updatedText = probabilistic.asof || anomalies.asof || anomalies.updated_at || meta?.last_updated_utc || "â€”";
    document.getElementById("updated").textContent = `${t("updatedPrefix")}: ${updatedText}`;
    document.getElementById("anomalyUpdated").textContent = `${t("updatedPrefix")}: ${updatedText}`;
    document.getElementById("anomalyScore").textContent = fmt(anomalies.anomaly_score, 0);
    document.getElementById("adxVal").textContent = fmt(anomalies.regime?.adx, 1);
    document.getElementById("atrVal").textContent = fmt(anomalies.regime?.atr, 4);
    document.getElementById("alertCount").textContent = anomalies.alerts?.length ?? 0;

    const trendLabel = anomalies.regime?.trend_state ?? "â€”";
    document.getElementById("trendTag").textContent = trendLabel;
    document.getElementById("trendNote").textContent = anomalies.regime?.ma50 && anomalies.regime?.ma200
      ? `${t("maLabel")}: ${fmt(anomalies.regime.ma50, 2)} / ${fmt(anomalies.regime.ma200, 2)}`
      : "â€”";

    const volLabel = anomalies.regime?.vol_state ?? "â€”";
    document.getElementById("volTag").textContent = `Vol ${volLabel}`;
    document.getElementById("volNote").textContent = anomalies.regime?.vol_state === "HIGH" ? "ATR elevated vs history" : anomalies.regime?.vol_state === "LOW" ? "ATR muted vs history" : "Within normal range";

    const lastClose = anomalies.price?.last_close ?? prices.close?.[prices.close.length - 1];
    document.getElementById("lastClose").textContent = fmt(lastClose, 2);
    document.getElementById("mas").textContent = `${t("maLabel")}: ${fmt(anomalies.price?.ma20,2)} / ${fmt(anomalies.price?.ma50,2)} / ${fmt(anomalies.price?.ma200,2)}`;
    const mom = prices.close?.length > 22 ? (prices.close[prices.close.length - 1] / prices.close[prices.close.length - 22] - 1) * 100 : null;
    document.getElementById("mom").textContent = fmt(mom, 2);

    const alerts = anomalies.alerts ?? [];
    document.getElementById("topAlert").textContent = alerts[0]?.why ?? t("noAlerts");
    const container = document.getElementById("alertsContainer");
    if (!alerts.length) {
      container.innerHTML = `<div class="muted">${t("noAlerts")}</div>`;
    } else {
      container.innerHTML = alerts.map((alert) => {
        const sev = alert.severity?.toLowerCase?.() || "info";
        return `
          <div class="alert-card">
            <div class="title">${alert.id} <span class="badge-inline sev-${sev}">${alert.severity}</span> <span class="badge-inline">${alert.direction}</span></div>
            <div class="muted">${alert.why}</div>
            <div class="muted small">z=${fmt(alert.evidence?.z,2)} Â· ${alert.historical_context?.occurrences || 0} past cases</div>
          </div>
        `;
      }).join("");
    }

    document.getElementById("perfSummaryUpdated").textContent = perfSummary.updated_at || "â€”";
    document.getElementById("perfSummaryUpdated2").textContent = perfSummary.updated_at || "â€”";
    const algoScore = perfSummary.algo_score || {};
    const algoComposite = algoScore.composite ?? algoScore.score ?? null;
    document.getElementById("algoScore").textContent = fmt(algoComposite, 0);
    const hit = fmtPct(algoScore.hit_rate ?? perfSummary.hit_rate, 0);
    const sharpe = fmt(algoScore.sharpe_ratio, 2);
    const cycle = fmtPct(algoScore.cycle_capture_rate, 0);
    document.getElementById("algoScoreMeta").textContent = `${t("hitRateLabel")}: ${hit} Â· ${t("sharpeLabel")}: ${sharpe} Â· ${t("cycleCaptureLabel")}: ${cycle}`;
    document.getElementById("hitRate").textContent = fmtPct(perfSummary.hit_rate, 0);
    document.getElementById("avgReturn5d").textContent = fmtPct(perfSummary.avg_return_5d, 2);
    document.getElementById("avgReturn10d").textContent = fmtPct(perfSummary.avg_return_10d, 2);
    document.getElementById("maxDrawdown").textContent = fmtPct(perfSummary.max_drawdown, 2);

    const decompMeta = decomposition.meta || {};
    const stl = decompMeta.stl || {};
    const params = [];
    if (stl.period_mode) params.push(`mode=${stl.period_mode}`);
    if (typeof stl.period === "number") params.push(`period=${stl.period}`);
    if (typeof stl.robust === "boolean") params.push(stl.robust ? "robust" : "not robust");
    document.getElementById("decompUpdated").textContent = decompMeta.asof || decompMeta.range?.end || "â€”";
    document.getElementById("decompPeriod").textContent = stl.period ?? "â€”";
    document.getElementById("decompInput").textContent = decompMeta.input ?? "â€”";
    document.getElementById("decompParams").textContent = params.length ? `${t("decompParamsLabel")}: ${params.join(" Â· ")}` : t("decompParamsLabel");
    const decompStatus = document.getElementById("decompStatus");
    if (decomposition.status !== "ok") {
      decompStatus.style.display = "block";
      decompStatus.textContent = decomposition.status === "missing" ? t("decompMissing") : `${t("decompUnavailable")} ${decomposition.error || ""}`;
    } else {
      decompStatus.style.display = "none";
      decompStatus.textContent = "";
    }
  }

  function renderDecomposition(range) {
    const chartIds = ["trendChart", "seasonalChart", "residualChart"];
    const months = range === "3m" ? 3 : range === "1y" ? 12 : null;
    const startBound = state.startDate ? new Date(state.startDate) : null;
    const endBound = state.endDate ? new Date(state.endDate) : null;
    const decompDates = (decomposition.dates || []).map((d) => new Date(d));
    const rangeStart = (() => {
      if (!months || !decompDates.length) return null;
      const lastDate = decompDates[decompDates.length - 1];
      const start = new Date(lastDate);
      start.setMonth(start.getMonth() - months);
      return start;
    })();

    const mask = [];
    decompDates.forEach((d, i) => {
      if (rangeStart && d < rangeStart) return;
      if (startBound && d < startBound) return;
      if (endBound && d > endBound) return;
      mask.push(i);
    });

    const showMessage = (msg) => {
      chartIds.forEach((id) => {
        const el = document.getElementById(id);
        if (window.Plotly) { Plotly.purge(el); }
        el.textContent = msg;
      });
    };

    if (decomposition.status === "missing") {
      showMessage(t("decompMissing"));
      return;
    }

    if (decomposition.status !== "ok") {
      showMessage(`${t("decompUnavailable")} ${decomposition.error || ""}`);
      return;
    }

    if (!mask.length) {
      showMessage(t("decompUnavailable"));
      return;
    }

    const dates = applyMask(decomposition.dates, mask);
    const trend = applyMask(decomposition.trend ?? [], mask);
    const seasonal = applyMask(decomposition.seasonal ?? [], mask);
    const residual = applyMask(decomposition.residual ?? [], mask);

    if (!trend.length || !seasonal.length || !residual.length) {
      showMessage(t("decompUnavailable"));
      return;
    }

    const layout = { paper_bgcolor: "rgba(0,0,0,0)", plot_bgcolor: "rgba(0,0,0,0)", margin: { l: 45, r: 15, t: 10, b: 30 }, xaxis: { showgrid: false, color: "#a8b4d6" }, yaxis: { showgrid: true, gridcolor: "#1e2a45", color: "#a8b4d6" } };
    Plotly.newPlot("trendChart", [{ x: dates, y: trend, mode: "lines", name: t("trendTitle"), line: { color: "#4c9cff" } }], layout, { displayModeBar: false });
    Plotly.newPlot("seasonalChart", [{ x: dates, y: seasonal, mode: "lines", name: t("seasonalTitle"), line: { color: "#fbbf24" } }], layout, { displayModeBar: false });
    Plotly.newPlot("residualChart", [{ x: dates, y: residual, mode: "lines", name: t("residualTitle"), line: { color: "#a855f7", dash: "dot" } }], layout, { displayModeBar: false });
  }

  function renderAll() {
    applyLanguage();
    updateAdvancedCopy();
    renderActionRecommendation(actionSignal, dataErrors.signalLatest, state.lang);
    renderEventContext(eventContext, eventImpactStats, dataErrors.eventContext);
    renderCrossMarketContextCard(
      crossMarketContext,
      currentContext,
      conditionalContextStats,
      dataErrors.crossMarketContext || dataErrors.crossMarketCurrent,
    );
    renderProbabilistic(probabilistic, dataErrors.probabilistic);
    renderProbabilityEngine(state.probabilityResult, state.probabilityEngine, dataErrors.prices || dataErrors.legacyPrices);
    renderProbabilitySettings(state.probabilityEngine);
    renderMeta();
    renderSummary();
    renderDeviationPanel();
    renderBandStats();
    renderHeatmap();
    renderPrice(state.range);
    renderEquity(state.range);
    renderTradeLog();
    renderDecomposition(state.range);
    syncPnlModeRadios();
    updateDateRangeUi();
  }

  renderAll();
  attachHeatmapControls();

  document.querySelectorAll('.btn[data-range]').forEach((btn) => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.btn[data-range]').forEach((b) => b.classList.remove('active'));
      btn.classList.add('active');
      state.range = btn.dataset.range;
      renderAll();
    });
  });

  document.getElementById("toggleMa").addEventListener("change", (e) => { state.showMa = e.target.checked; renderPrice(state.range); });
  document.getElementById("toggleBoll").addEventListener("change", (e) => { state.showBoll = e.target.checked; renderPrice(state.range); });
  document.getElementById("toggleCycles").addEventListener("change", (e) => { state.showCycles = e.target.checked; renderPrice(state.range); });

  const probInfoBtn = document.getElementById("probEngineInfoBtn");
  if (probInfoBtn) {
    probInfoBtn.addEventListener("click", () => {
      openHowItWorks(state.lang);
    });
  }

  const howItWorksBtn = document.getElementById("howItWorksBtn");
  if (howItWorksBtn) {
    howItWorksBtn.addEventListener("click", () => openHowItWorks(state.lang));
  }

  const advancedShortcut = document.getElementById("advancedShortcut");
  if (advancedShortcut) {
    advancedShortcut.addEventListener("click", () => openAdvancedSection(true));
  }

  const probSettingsToggle = document.getElementById("probEngineSettingsToggle");
  const probSettingsPanel = document.getElementById("probEngineSettingsPanel");
  if (probSettingsToggle && probSettingsPanel) {
    probSettingsToggle.addEventListener("click", () => {
      const isHidden = probSettingsPanel.style.display === "none";
      probSettingsPanel.style.display = isHidden ? "grid" : "none";
      probSettingsToggle.classList.toggle("active", isHidden);
    });
  }

  const applyProbabilitySettings = () => {
    const horizon = Number(document.getElementById("probSettingHorizon")?.value) || state.probabilityEngine.horizon;
    const k = Number(document.getElementById("probSettingK")?.value) || state.probabilityEngine.k;
    const weighting = document.getElementById("probSettingWeighting")?.value || state.probabilityEngine.weighting;
    const thresholdPct = Number(document.getElementById("probSettingThreshold")?.value) || 0;
    const highlightPct = Number(document.getElementById("probSettingHighlight")?.value);

    state.probabilityEngine = {
      ...state.probabilityEngine,
      horizon,
      k,
      weighting,
      threshold: thresholdPct / 100,
      highlightThreshold: Number.isFinite(highlightPct) ? highlightPct / 100 : state.probabilityEngine.highlightThreshold,
    };

    state.probabilityResult = featureRows.length ? knnAnalogProbability(featureRows, state.probabilityEngine) : null;
    renderProbabilityEngine(state.probabilityResult, state.probabilityEngine, dataErrors.prices || dataErrors.legacyPrices);
    renderProbabilitySettings(state.probabilityEngine);
  };

  const probApplyBtn = document.getElementById("probEngineApply");
  if (probApplyBtn) probApplyBtn.addEventListener("click", applyProbabilitySettings);

  const langSelect = document.getElementById("langSelect");
  if (langSelect) {
    langSelect.addEventListener("change", (e) => {
      const selected = e.target.value;
      if (supportedLanguages.includes(selected)) {
        state.lang = selected;
        localStorage.setItem("lang", state.lang);
        renderAll();
      }
    });
  }

    const startInput = document.getElementById("startDate");
    const endInput = document.getElementById("endDate");
    const dateRangeSelect = document.getElementById("dateRangeSelect");

    startInput.value = state.startDate.slice(0, 10);
    endInput.value = state.endDate.slice(0, 10);
    document.getElementById("costsInput").value = state.costBps;
    document.getElementById("slippageInput").value = state.slippageBps;
    document.getElementById("useAtrSizing").checked = state.useAtrSizing;
    document.getElementById("targetDailyVol").value = state.targetDailyVol;
    document.getElementById("useStopLoss").checked = state.useStopLoss;
    document.getElementById("stopAtrMult").value = state.stopAtrMult;
    document.getElementById("useTrailingStop").checked = state.useTrailingStop;
    document.getElementById("trailingAtrMult").value = state.trailingAtrMult;
    document.getElementById("useVarSizing").checked = state.useVarSizing;
    document.getElementById("varConfidence").value = state.varConfidence;
    document.getElementById("varRisk").value = state.varRisk;
    document.getElementById("varLookback").value = state.varLookback;

    const syncDates = () => {
      const startDate = new Date(state.startDate);
      const endDate = new Date(state.endDate);
      if (startDate > endDate) { state.endDate = state.startDate; endInput.value = state.endDate.slice(0, 10); }
    };

    const applyDateRangePreset = (preset) => {
      state.dateRangePreset = preset;
      const dateStrings = Array.isArray(prices?.dates) ? prices.dates.filter(Boolean) : [];
      const lastDateStr = dateStrings[dateStrings.length - 1];
      const firstDateStr = dateStrings[0];
      if (!firstDateStr || !lastDateStr) return;
      if (preset === "custom") { updateDateRangeUi(); return; }
      const months = preset === "1y" ? 12 : preset === "3y" ? 36 : preset === "5y" ? 60 : null;
      if (months) {
        const start = new Date(lastDateStr);
        start.setMonth(start.getMonth() - months);
        state.startDate = start.toISOString().slice(0, 10);
        state.endDate = lastDateStr;
      } else {
        state.startDate = firstDateStr;
        state.endDate = lastDateStr;
      }
      startInput.value = state.startDate.slice(0, 10);
      endInput.value = state.endDate.slice(0, 10);
      updateDateRangeUi();
      renderAll();
    };

    dateRangeSelect.addEventListener("change", (e) => applyDateRangePreset(e.target.value));
    startInput.addEventListener("change", (e) => { state.startDate = e.target.value || state.startDate; state.dateRangePreset = "custom"; dateRangeSelect.value = "custom"; syncDates(); renderAll(); });
    endInput.addEventListener("change", (e) => { state.endDate = e.target.value || state.endDate; state.dateRangePreset = "custom"; dateRangeSelect.value = "custom"; syncDates(); renderAll(); });

    document.getElementById("costsInput").addEventListener("input", (e) => { state.costBps = Number(e.target.value) || 0; state.useCustomBacktest = true; renderEquity(state.range); });
    document.getElementById("slippageInput").addEventListener("input", (e) => { state.slippageBps = Number(e.target.value) || 0; state.useCustomBacktest = true; });
    document.getElementById("strategySelect").addEventListener("change", (e) => { state.strategy = e.target.value; });
    document.getElementById("useAtrSizing").addEventListener("change", (e) => { state.useAtrSizing = e.target.checked; state.useCustomBacktest = true; });
    document.getElementById("targetDailyVol").addEventListener("input", (e) => { state.targetDailyVol = Number(e.target.value) || state.targetDailyVol; state.useCustomBacktest = true; });
    document.getElementById("useStopLoss").addEventListener("change", (e) => { state.useStopLoss = e.target.checked; state.useCustomBacktest = true; });
    document.getElementById("stopAtrMult").addEventListener("input", (e) => { state.stopAtrMult = Number(e.target.value) || state.stopAtrMult; state.useCustomBacktest = true; });
    document.getElementById("useTrailingStop").addEventListener("change", (e) => { state.useTrailingStop = e.target.checked; state.useCustomBacktest = true; });
    document.getElementById("trailingAtrMult").addEventListener("input", (e) => { state.trailingAtrMult = Number(e.target.value) || state.trailingAtrMult; state.useCustomBacktest = true; });
    document.getElementById("useVarSizing").addEventListener("change", (e) => { state.useVarSizing = e.target.checked; state.useCustomBacktest = true; });
    document.getElementById("varConfidence").addEventListener("input", (e) => { state.varConfidence = Number(e.target.value) || state.varConfidence; state.useCustomBacktest = true; });
    document.getElementById("varRisk").addEventListener("input", (e) => { state.varRisk = Number(e.target.value) || state.varRisk; state.useCustomBacktest = true; });
    document.getElementById("varLookback").addEventListener("input", (e) => { state.varLookback = Number(e.target.value) || state.varLookback; state.useCustomBacktest = true; });

    document.querySelectorAll('input[name="equityMode"]').forEach((r) => {
      r.addEventListener('change', (e) => { state.showNet = e.target.value === 'net'; syncPnlModeRadios(); renderEquity(state.range); });
    });
    document.querySelectorAll('input[name="pnlMode"]').forEach((r) => {
      r.addEventListener('change', (e) => { state.showNet = e.target.value === 'net'; syncPnlModeRadios(); renderEquity(state.range); });
    });

    const sensToggle = document.getElementById("toggleFeesSensitivity");
    if (sensToggle) {
      sensToggle.addEventListener('change', (e) => { state.showSensitivity = e.target.checked; renderEquity(state.range); });
    }

    document.getElementById("runSimulation").addEventListener("click", () => { state.useCustomBacktest = true; renderAll(); });
  } catch (err) {
    console.error("Failed to initialize dashboard", err);
    const updated = document.getElementById("updated");
    if (updated) updated.textContent = `Error loading data: ${err.message}`;
    showGlobalError(err?.message || "Data load failed");
    if (err instanceof FetchAllCandidatesError && err.details) {
      console.table(err.details);
    }
  } finally {
    attachAdvancedToggle();
    updateAdvancedCopy();
  }
})();
</script>
</body>
</html>
